{"file_path": "/home/Downloads/project/c-project/numpy/numpy/core/src/umath/ufunc_object.c", "function": "cmp_arg_types(int *arg1, int *arg2, int n)\n{\n    for (; n > 0; n--, arg1++, arg2++) {\n        if (PyArray_EquivTypenums(*arg1, *arg2)) {\n            continue;\n        }\n        if (PyArray_CanCastSafely(*arg1, *arg2)) {\n            return -1;\n        }\n        return 1;\n    }\n    return 0;\n}", "summary": "return 1 if arg1 arg2 0 if arg1 arg2 and 1 if arg1 arg2"}
{"file_path": "/home/Downloads/project/c-project/libgit2/src/win32/thread.c", "function": "static DWORD WINAPI git_win32__threadproc(LPVOID lpParameter)\n{\n\tgit_thread *thread = lpParameter;\n\n\t/* Set the current thread for `git_thread_exit` */\n\tGIT_GLOBAL->current_thread = thread;\n\n\tthread->result = thread->proc(thread->param);\n\n\treturn CLEAN_THREAD_EXIT;\n}", "summary": "The thread procedure stub used to invoke the caller s procedure and capture the return value for later collection"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Cedar/IPC.c", "function": "void IPCSendIPv4WithDestMacAddr(IPC *ipc, void *data, UINT size, UCHAR *dest_mac_addr)\n{\n\tUCHAR tmp[1514];\n\t// Validate arguments\n\tif (ipc == NULL || data == NULL || size < 20 || size > 1500 || dest_mac_addr == NULL)\n\t{\n\t\treturn;\n\t}\n\n\t// Destination\n\tCopy(tmp + 0, dest_mac_addr, 6);\n\n\t// Source\n\tCopy(tmp + 6, ipc->MacAddress, 6);\n\n\t// Protocol number\n\tWRITE_USHORT(tmp + 12, MAC_PROTO_IPV4);\n\n\t// Data\n\tCopy(tmp + 14, data, size);\n\n\t// Send\n\tIPCSendL2(ipc, tmp, size + 14);\n}", "summary": "Send an IPv4 packet with a specified destination MAC address"}
{"file_path": "/home/Downloads/project/platform/arduino/src/src/lv_core/lv_indev.c", "function": "lv_task_t * lv_indev_get_read_task(lv_disp_t * indev)\n{\n    if(!indev) {\n        LV_LOG_WARN(\"lv_indev_get_read_task: indev was NULL\");\n        return NULL;\n    }\n\n    return indev->refr_task;\n}", "summary": "Get a pointer to the indev read task to modify its parameters with lv_task_ functions"}
{"file_path": "/home/Downloads/project/c-project/anypixel/firmware/display/ThirdParty/SPL/src/stm32f0xx_i2c.c", "function": "void I2C_NumberOfBytesConfig(I2C_TypeDef* I2Cx, uint8_t Number_Bytes)\n{\n  uint32_t tmpreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n\n  /* Get the old register value */\n  tmpreg = I2Cx->CR2;\n\n  /* Reset I2Cx Nbytes bit [7:0] */\n  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);\n\n  /* Set I2Cx Nbytes */\n  tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);\n\n  /* Store the new register value */\n  I2Cx->CR2 = tmpreg;\n}", "summary": "Configures the number of bytes to be transmitted received"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/powerpc/kvm/e500.c", "function": "static void kvmppc_e500_recalc_shadow_pid(struct kvmppc_vcpu_e500 *vcpu_e500)\n{\n\tpreempt_disable();\n\tvcpu_e500->vcpu.arch.shadow_pid = kvmppc_e500_get_sid(vcpu_e500,\n\t\t\tget_cur_as(&vcpu_e500->vcpu),\n\t\t\tget_cur_pid(&vcpu_e500->vcpu),\n\t\t\tget_cur_pr(&vcpu_e500->vcpu), 1);\n\tvcpu_e500->vcpu.arch.shadow_pid1 = kvmppc_e500_get_sid(vcpu_e500,\n\t\t\tget_cur_as(&vcpu_e500->vcpu), 0,\n\t\t\tget_cur_pr(&vcpu_e500->vcpu), 1);\n\tpreempt_enable();\n}", "summary": "Map guest pid to shadow"}
{"file_path": "/home/Downloads/project/c-project/masscan/src/proto-ssl.c", "function": "ssl_hello_size(const void *templ)\n{\n    const unsigned char *px = (const unsigned char *)templ;\n    size_t template_size;\n    \n    template_size = (px[3]<<8 | px[4]) + 5;\n    \n    return (unsigned)template_size;\n}", "summary": "Figure out the Hello message size by parsing the data"}
{"file_path": "/home/Downloads/project/homebrew/sqlcipher/ext/misc/fuzzer.c", "function": "static int fuzzerColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){\n  fuzzer_cursor *pCur = (fuzzer_cursor*)cur;\n  if( i==0 ){\n    /* the \"word\" column */\n    if( fuzzerRender(pCur->pStem, &pCur->zBuf, &pCur->nBuf)==SQLITE_NOMEM ){\n      return SQLITE_NOMEM;\n    }\n    sqlite3_result_text(ctx, pCur->zBuf, -1, SQLITE_TRANSIENT);\n  }else if( i==1 ){\n    /* the \"distance\" column */\n    sqlite3_result_int(ctx, pCur->pStem->rCostX);\n  }else{\n    /* All other columns are NULL */\n    sqlite3_result_null(ctx);\n  }\n  return SQLITE_OK;\n}", "summary": "Only the word and distance columns have values"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/wireless/ralink/rt2x00/rt2800usb.c", "function": "static __le32 *rt2800usb_get_txwi(struct queue_entry *entry)\n{\n\tif (entry->queue->qid == QID_BEACON)\n\t\treturn (__le32 *) (entry->skb->data);\n\telse\n\t\treturn (__le32 *) (entry->skb->data + TXINFO_DESC_SIZE);\n}", "summary": "TX descriptor initialization"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/scsi/libsas/sas_port.c", "function": "void sas_porte_bytes_dmaed(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_form_port(phy);\n}", "summary": "SAS port events"}
{"file_path": "/home/Downloads/project/homebrew/xaric/keys.c", "function": "void cmd_parsekey(struct command *cmd, char *args)\n{\n    int i;\n    char *arg;\n\n    if ((arg = next_arg(args, &args)) != NULL) {\n\tswitch (lookup_function(arg, &i)) {\n\tcase 0:\n\t    say(\"No such function %s\", arg);\n\t    return;\n\tcase 1:\n\t    key_names[i].func(0, args);\n\t    break;\n\tdefault:\n\t    say(\"Ambigious function %s\", arg);\n\t    break;\n\t}\n    }\n}", "summary": "parsekeycmd does the PARSEKEY command"}
{"file_path": "/home/Downloads/project/homebrew/silc/lib/silcmath/tma.c", "function": "int tma_mp_reduce_2k_setup_l(tma_mp_int *a, tma_mp_int *d)\n{\n   int    res;\n   tma_mp_int tmp;\n\n   if ((res = tma_mp_init(&tmp)) != MP_OKAY) {\n      return res;\n   }\n\n   if ((res = tma_mp_2expt(&tmp, tma_mp_count_bits(a))) != MP_OKAY) {\n      goto ERR;\n   }\n\n   if ((res = s_tma_mp_sub(&tmp, a, d)) != MP_OKAY) {\n      goto ERR;\n   }\n\nERR:\n   tma_mp_clear(&tmp);\n   return res;\n}", "summary": "determines the setup value"}
{"file_path": "/home/Downloads/project/homebrew/suricata/src/detect-id.c", "function": "void DetectIdRegister (void)\n{\n    sigmatch_table[DETECT_ID].name = \"id\";\n    sigmatch_table[DETECT_ID].desc = \"match on a specific IP ID value\";\n    sigmatch_table[DETECT_ID].url = DOC_URL DOC_VERSION \"/rules/header-keywords.html#id\";\n    sigmatch_table[DETECT_ID].Match = DetectIdMatch;\n    sigmatch_table[DETECT_ID].Setup = DetectIdSetup;\n    sigmatch_table[DETECT_ID].Free  = DetectIdFree;\n    sigmatch_table[DETECT_ID].RegisterTests = DetectIdRegisterTests;\n\n    sigmatch_table[DETECT_ID].SupportsPrefilter = PrefilterIdIsPrefilterable;\n    sigmatch_table[DETECT_ID].SetupPrefilter = PrefilterSetupId;\n\n    DetectSetupParseRegexes(PARSE_REGEX, &parse_regex, &parse_regex_study);\n}", "summary": "brief Registration function for keyword id"}
{"file_path": "/home/Downloads/project/homebrew/suricata/src/detect-dce-opnum.c", "function": "void DetectDceOpnumRegister(void)\n{\n    sigmatch_table[DETECT_DCE_OPNUM].name = \"dcerpc.opnum\";\n    sigmatch_table[DETECT_DCE_OPNUM].alias = \"dce_opnum\";\n    sigmatch_table[DETECT_DCE_OPNUM].AppLayerTxMatch = DetectDceOpnumMatchRust;\n    sigmatch_table[DETECT_DCE_OPNUM].Setup = DetectDceOpnumSetup;\n    sigmatch_table[DETECT_DCE_OPNUM].Free  = DetectDceOpnumFree;\n    sigmatch_table[DETECT_DCE_OPNUM].RegisterTests = DetectDceOpnumRegisterTests;\n\n    DetectSetupParseRegexes(PARSE_REGEX, &parse_regex, &parse_regex_study);\n\n    g_dce_generic_list_id = DetectBufferTypeRegister(\"dce_generic\");\n}", "summary": "brief Registers the keyword handlers for the dce_opnum keyword"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/x86/kernel/setup.c", "function": "static void __init trim_snb_memory(void)\n{\n\tstatic const __initconst unsigned long bad_pages[] = {\n\t\t0x20050000,\n\t\t0x20110000,\n\t\t0x20130000,\n\t\t0x20138000,\n\t\t0x40004000,\n\t};\n\tint i;\n\n\tif (!snb_gfx_workaround_needed())\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"reserving inaccessible SNB gfx pages\\n\");\n\n\t/*\n\t * Reserve all memory below the 1 MB mark that has not\n\t * already been reserved.\n\t */\n\tmemblock_reserve(0, 1<<20);\n\t\n\tfor (i = 0; i < ARRAY_SIZE(bad_pages); i++) {\n\t\tif (memblock_reserve(bad_pages[i], PAGE_SIZE))\n\t\t\tprintk(KERN_WARNING \"failed to reserve 0x%08lx\\n\",\n\t\t\t       bad_pages[i]);\n\t}\n}", "summary": "Sandy Bridge graphics has trouble with certain ranges exclude them from allocation"}
{"file_path": "/home/Downloads/project/c-project/nodemcu-firmware/app/libc/stdio.c", "function": "static int _finite(rtype d)\n{\n#if ENDIAN == ENDIAN_LITTLE\n    struct IEEEdp {\n    unsigned manl:32;\n    unsigned manh:20;\n    unsigned exp:11;\n    unsigned sign:1;\n    } *ip;\n#else\n    struct IEEEdp {\n    unsigned sign:1;\n    unsigned exp:11;\n    unsigned manh:20;\n    unsigned manl:32;\n    } *ip;\n#endif\n\n    ip = (struct IEEEdp *)&d;\n    return (ip->exp != 0x7ff);\n}", "summary": "arg not Infinity or Nan"}
{"file_path": "/home/Downloads/project/platform/arduino/src/src/lv_objx/lv_mbox.c", "function": "void lv_mbox_set_text(lv_obj_t * mbox, const char * txt)\n{\n    LV_ASSERT_OBJ(mbox, LV_OBJX_NAME);\n    LV_ASSERT_STR(txt);\n\n    lv_mbox_ext_t * ext = lv_obj_get_ext_attr(mbox);\n    lv_label_set_text(ext->text, txt);\n\n    mbox_realign(mbox);\n}", "summary": "Set the text of the message box"}
{"file_path": "/home/Downloads/project/c-project/linux/mm/vmstat.c", "function": "static void zero_zone_numa_counters(struct zone *zone)\n{\n\tint item, cpu;\n\n\tfor (item = 0; item < NR_VM_NUMA_STAT_ITEMS; item++) {\n\t\tatomic_long_set(&zone->vm_numa_stat[item], 0);\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->vm_numa_stat_diff[item]\n\t\t\t\t\t\t= 0;\n\t}\n}", "summary": "zero numa counters within a zone"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/scsi/bfa/bfa_fcs.c", "function": "bfa_fcs_fabric_flogiacc_comp(void *fcsarg, struct bfa_fcxp_s *fcxp, void *cbarg,\n\t\t\t     bfa_status_t status, u32 rsp_len,\n\t\t\t     u32 resid_len, struct fchs_s *rspfchs)\n{\n\tstruct bfa_fcs_fabric_s *fabric = cbarg;\n\n\tbfa_trc(fabric->fcs, status);\n}", "summary": "Flogi Acc completion callback"}
{"file_path": "/home/Downloads/project/c-project/linux/lib/bitmap.c", "function": "static int bitmap_pos_to_ord(const unsigned long *buf, unsigned int pos, unsigned int nbits)\n{\n\tif (pos >= nbits || !test_bit(pos, buf))\n\t\treturn -1;\n\n\treturn __bitmap_weight(buf, pos);\n}", "summary": "find ordinal of set bit at given position in bitmap"}
{"file_path": "/home/Downloads/project/c-project/mpv/input/input.c", "function": "static bool should_drop_cmd(struct input_ctx *ictx, struct mp_cmd *cmd)\n{\n    struct cmd_queue *queue = &ictx->cmd_queue;\n    return queue_count_cmds(queue) >= ictx->opts->key_fifo_size;\n}", "summary": "could lead to situations where recovery would take too long"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Mayaqua/Encrypt.c", "function": "void OpenSSL_Lock(int mode, int n, const char *file, int line)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)\n\tLOCK *lock = ssl_lock_obj[n];\n\n\tif (mode & CRYPTO_LOCK)\n\t{\n\t\t// Lock\n\t\tLock(lock);\n\t}\n\telse\n\t{\n\t\t// Unlock\n\t\tUnlock(lock);\n\t}\n#endif\n}", "summary": "Lock function for OpenSSL"}
{"file_path": "/home/Downloads/project/homebrew/libsrtp/crypto/test/kernel_driver.c", "function": "srtp_err_status_t crypto_kernel_cipher_test(void)\n{\n    /* not implemented yet! */\n\n    return srtp_err_status_ok;\n}", "summary": "is a test of the cipher interface of the crypto_kernel"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/mtd/devices/st_spi_fsm.c", "function": "static int stfsm_prepare_rwe_seqs_default(struct stfsm *fsm)\n{\n\tuint32_t flags = fsm->info->flags;\n\tint ret;\n\n\t/* Configure 'READ' sequence */\n\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\n\t\t\t\t\t  default_read_configs);\n\tif (ret) {\n\t\tdev_err(fsm->dev,\n\t\t\t\"failed to prep READ sequence with flags [0x%08x]\\n\",\n\t\t\tflags);\n\t\treturn ret;\n\t}\n\n\t/* Configure 'WRITE' sequence */\n\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_write,\n\t\t\t\t\t  default_write_configs);\n\tif (ret) {\n\t\tdev_err(fsm->dev,\n\t\t\t\"failed to prep WRITE sequence with flags [0x%08x]\\n\",\n\t\t\tflags);\n\t\treturn ret;\n\t}\n\n\t/* Configure 'ERASE_SECTOR' sequence */\n\tstfsm_prepare_erasesec_seq(fsm, &stfsm_seq_erase_sector);\n\n\treturn 0;\n}", "summary": "Prepare a READ WRITE ERASE default sequences"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/staging/nvec/nvec.c", "function": "static int nvec_status_notifier(struct notifier_block *nb,\n\t\t\t\tunsigned long event_type, void *data)\n{\n\tstruct nvec_chip *nvec = container_of(nb, struct nvec_chip,\n\t\t\t\t\t\tnvec_status_notifier);\n\tunsigned char *msg = data;\n\n\tif (event_type != NVEC_CNTL)\n\t\treturn NOTIFY_DONE;\n\n\tdev_warn(nvec->dev, \"unhandled msg type %ld\\n\", event_type);\n\tprint_hex_dump(KERN_WARNING, \"payload: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       msg, msg[1] + 2, true);\n\n\treturn NOTIFY_OK;\n}", "summary": "The final notifier Prints a message about control events not handled in the notifier chain"}
{"file_path": "/home/Downloads/project/homebrew/openjpeg/thirdparty/liblcms2/src/cmsplugin.c", "function": "cmsFloat64Number CMSEXPORT _cms8Fixed8toDouble(cmsUInt16Number fixed8)\n{\n       cmsUInt8Number  msb, lsb;\n\n       lsb = (cmsUInt8Number) (fixed8 & 0xff);\n       msb = (cmsUInt8Number) (((cmsUInt16Number) fixed8 >> 8) & 0xff);\n\n       return (cmsFloat64Number) ((cmsFloat64Number) msb + ((cmsFloat64Number) lsb / 256.0));\n}", "summary": "from Fixed point 8 8 to double"}
{"file_path": "/home/Downloads/project/c-project/radare2/libr/magic/apprentice.c", "function": "static int apprentice_sort(const void *a, const void *b) {\n\tconst struct r_magic_entry *ma = a;\n\tconst struct r_magic_entry *mb = b;\n\tsize_t sa = apprentice_r_magic_strength (ma->mp);\n\tsize_t sb = apprentice_r_magic_strength (mb->mp);\n\tif (sa == sb) {\n\t\treturn 0;\n\t}\n\tif (sa > sb) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}", "summary": "Sort callback for sorting entries by strength basically length"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/intel/i40e/i40e_main.c", "function": "static i40e_status i40e_pf_loop_reset(struct i40e_pf *pf)\n{\n\tconst unsigned short MAX_CNT = 1000;\n\tconst unsigned short MSECS = 10;\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status ret;\n\tint cnt;\n\n\tfor (cnt = 0; cnt < MAX_CNT; ++cnt) {\n\t\tret = i40e_pf_reset(hw);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tmsleep(MSECS);\n\t}\n\n\tif (cnt == MAX_CNT) {\n\t\tdev_info(&pf->pdev->dev, \"PF reset failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpf->pfr_count++;\n\treturn ret;\n}", "summary": "perform reset in a loop"}
{"file_path": "/home/Downloads/project/c-project/postgres/src/backend/utils/misc/guc.c", "function": "discard_stack_value(struct config_generic *gconf, config_var_value *val)\n{\n\tswitch (gconf->vartype)\n\t{\n\t\tcase PGC_BOOL:\n\t\tcase PGC_INT:\n\t\tcase PGC_REAL:\n\t\tcase PGC_ENUM:\n\t\t\t/* no need to do anything */\n\t\t\tbreak;\n\t\tcase PGC_STRING:\n\t\t\tset_string_field((struct config_string *) gconf,\n\t\t\t\t\t\t\t &(val->val.stringval),\n\t\t\t\t\t\t\t NULL);\n\t\t\tbreak;\n\t}\n\tset_extra_field(gconf, &(val->extra), NULL);\n}", "summary": "Support for discarding a no longer needed value in a stack entry"}
{"file_path": "/home/Downloads/project/c-project/postgres/src/backend/access/index/indexam.c", "function": "index_beginscan_parallel(Relation heaprel, Relation indexrel, int nkeys,\n\t\t\t\t\t\t int norderbys, ParallelIndexScanDesc pscan)\n{\n\tSnapshot\tsnapshot;\n\tIndexScanDesc scan;\n\n\tAssert(RelationGetRelid(heaprel) == pscan->ps_relid);\n\tsnapshot = RestoreSnapshot(pscan->ps_snapshot_data);\n\tRegisterSnapshot(snapshot);\n\tscan = index_beginscan_internal(indexrel, nkeys, norderbys, snapshot,\n\t\t\t\t\t\t\t\t\tpscan, true);\n\n\t/*\n\t * Save additional parameters into the scandesc.  Everything else was set\n\t * up by index_beginscan_internal.\n\t */\n\tscan->heapRelation = heaprel;\n\tscan->xs_snapshot = snapshot;\n\n\t/* prepare to fetch index matches from table */\n\tscan->xs_heapfetch = table_index_fetch_begin(heaprel);\n\n\treturn scan;\n}", "summary": "join parallel index scan Caller must be holding suitable locks on the heap and the index"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/arm/mm/copypage-v6.c", "function": "static void v6_clear_user_highpage_nonaliasing(struct page *page, unsigned long vaddr)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tclear_page(kaddr);\n\tkunmap_atomic(kaddr);\n}", "summary": "Clear the user page"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/cpuidle/cpuidle-kirkwood.c", "function": "static int kirkwood_cpuidle_probe(struct platform_device *pdev)\n{\n\tddr_operation_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ddr_operation_base))\n\t\treturn PTR_ERR(ddr_operation_base);\n\n\treturn cpuidle_register(&kirkwood_idle_driver, NULL);\n}", "summary": "Initialize CPU idle by registering the idle states"}
{"file_path": "/home/Downloads/project/c-project/FFmpeg/libavfilter/vf_overlay_qsv.c", "function": "static int filter_callback(AVFilterLink *outlink, AVFrame *frame)\n{\n    QSVOverlayContext *s = outlink->src->priv;\n    frame->pts = av_rescale_q(s->fs.pts,\n                              s->fs.time_base, outlink->time_base);\n    return ff_filter_frame(outlink, frame);\n}", "summary": "Callback for qsvvpp"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/microchip/enc28j60.c", "function": "static u16 enc28j60_phy_read(struct enc28j60_net *priv, u8 address)\n{\n\tu16 ret;\n\n\tmutex_lock(&priv->lock);\n\t/* set the PHY register address */\n\tnolock_regb_write(priv, MIREGADR, address);\n\t/* start the register read operation */\n\tnolock_regb_write(priv, MICMD, MICMD_MIIRD);\n\t/* wait until the PHY read completes */\n\twait_phy_ready(priv);\n\t/* quit reading */\n\tnolock_regb_write(priv, MICMD, 0x00);\n\t/* return the data */\n\tret = nolock_regw_read(priv, MIRDL);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}", "summary": "PHY register read PHY registers are not accessed directly but through the MII"}
{"file_path": "/home/Downloads/project/homebrew/libtommath/mp_from_sbin.c", "function": "mp_err mp_from_sbin(mp_int *a, const uint8_t *buf, size_t size)\n{\n   mp_err err;\n\n   /* read magnitude */\n   if ((err = mp_from_ubin(a, buf + 1, size - 1u)) != MP_OKAY) {\n      return err;\n   }\n\n   /* first byte is 0 for positive, non-zero for negative */\n   a->sign = (buf[0] != (uint8_t)0) ? MP_NEG : MP_ZPOS;\n\n   return MP_OKAY;\n}", "summary": "read signed bin big endian first byte is 0 positive or 1 negative"}
{"file_path": "/home/Downloads/project/c-project/linux/net/decnet/dn_nsp_out.c", "function": "static inline unsigned int dn_nsp_clone_and_send(struct sk_buff *skb,\n\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct dn_skb_cb *cb = DN_SKB_CB(skb);\n\tstruct sk_buff *skb2;\n\tint ret = 0;\n\n\tif ((skb2 = skb_clone(skb, gfp)) != NULL) {\n\t\tret = cb->xmit_count;\n\t\tcb->xmit_count++;\n\t\tcb->stamp = jiffies;\n\t\tskb2->sk = skb->sk;\n\t\tdn_nsp_send(skb2);\n\t}\n\n\treturn ret;\n}", "summary": "Send a data packet by cloning it"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/scsi/megaraid/megaraid_sas_fusion.c", "function": "inline struct megasas_cmd_fusion *megasas_get_cmd_fusion(struct megasas_instance\n\t\t\t\t\t\t  *instance, u32 blk_tag)\n{\n\tstruct fusion_context *fusion;\n\n\tfusion = instance->ctrl_context;\n\treturn fusion->cmd_list[blk_tag];\n}", "summary": "Get a command from the free pool"}
{"file_path": "/home/Downloads/project/c-project/FFmpeg/libavcodec/atrac3plus.c", "function": "static inline void unpack_vq_shape(int start_val, const int8_t *shape_vec,\n                                   int *dst, int num_values)\n{\n    int i;\n\n    if (num_values) {\n        dst[0] = dst[1] = dst[2] = start_val;\n        for (i = 3; i < num_values; i++)\n            dst[i] = start_val - shape_vec[atrac3p_qu_num_to_seg[i] - 1];\n    }\n}", "summary": "Unpack vector quantization tables"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/chelsio/cxgb3/sge.c", "function": "static inline void check_ring_tx_db(struct adapter *adap, struct sge_txq *q)\n{\n#if USE_GTS\n\tclear_bit(TXQ_LAST_PKT_DB, &q->flags);\n\tif (test_and_set_bit(TXQ_RUNNING, &q->flags) == 0) {\n\t\tset_bit(TXQ_LAST_PKT_DB, &q->flags);\n\t\tt3_write_reg(adap, A_SG_KDOORBELL,\n\t\t\t     F_SELEGRCNTX | V_EGRCNTX(q->cntxt_id));\n\t}\n#else\n\twmb();\t\t\t/* write descriptors before telling HW */\n\tt3_write_reg(adap, A_SG_KDOORBELL,\n\t\t     F_SELEGRCNTX | V_EGRCNTX(q->cntxt_id));\n#endif\n}", "summary": "check and potentially ring a Tx queue s doorbell"}
{"file_path": "/home/Downloads/project/homebrew/xaric/ternary.c", "function": "struct tnode *t_build(struct tnode *root, struct command c[], int n)\n{\n    int m;\n\n    if (n < 1)\n\treturn root;\n    m = n / 2;\n    root = t_insert(root, c[m].name, &c[m]);\n\n    root = t_build(root, c, m);\n    root = t_build(root, c + m + 1, n - m - 1);\n    return root;\n}", "summary": "given an array insert all the commands"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Cedar/Protocol.c", "function": "PACK *PackHello(void *random, UINT ver, UINT build, char *server_str)\n{\n\tPACK *p;\n\t// Validate arguments\n\tif (random == NULL || server_str == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tp = NewPack();\n\tPackAddStr(p, \"hello\", server_str);\n\tPackAddInt(p, \"version\", ver);\n\tPackAddInt(p, \"build\", build);\n\tPackAddData(p, \"random\", random, SHA1_SIZE);\n\n\treturn p;\n}", "summary": "Create a Hello packet"}
{"file_path": "/home/Downloads/project/c-project/linux/fs/ocfs2/journal.c", "function": "int ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}", "summary": "full flag tells us whether we clear out all blocks or if we just mark the journal clean"}
{"file_path": "/home/Downloads/project/c-project/linux/fs/udf/inode.c", "function": "static void udf_do_extend_final_block(struct inode *inode,\n\t\t\t\t      struct extent_position *last_pos,\n\t\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t\t      uint32_t final_block_len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tuint32_t added_bytes;\n\n\tadded_bytes = final_block_len -\n\t\t      (last_ext->extLength & (sb->s_blocksize - 1));\n\tlast_ext->extLength += added_bytes;\n\tUDF_I(inode)->i_lenExtents += added_bytes;\n\n\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\tlast_ext->extLength, 1);\n}", "summary": "Extend the final block of the file to final_block_len bytes"}
{"file_path": "/home/Downloads/project/homebrew/Tor/src/or/main.c", "function": "dns_servers_relaunch_checks(void)\n{\n  if (server_mode(get_options())) {\n    dns_reset_correctness_checks();\n    time_to_check_for_correct_dns = 0;\n  }\n}", "summary": "Forget what we ve learned about the correctness of our DNS servers and start learning again"}
{"file_path": "/home/Downloads/project/homebrew/sqlcipher/src/test7.c", "function": "static void stop_thread(Thread *p){\n  client_wait(p);\n  p->xOp = 0;\n  p->opnum++;\n  client_wait(p);\n  sqlite3_free(p->zArg);\n  p->zArg = 0;\n  sqlite3_free(p->zFilename);\n  p->zFilename = 0;\n  p->busy = 0;\n}", "summary": "Stop a thread"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Mayaqua/Memory.c", "function": "UINT PRandInt(PRAND *p)\n{\n\tUINT r;\n\tif (p == NULL)\n\t{\n\t\treturn 0;\n\t}\n\n\tPRand(p, &r, sizeof(UINT));\n\n\treturn r;\n}", "summary": "Generate UINT PRand"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/pci/controller/pci-hyperv.c", "function": "static int hv_pci_query_relations(struct hv_device *hdev)\n{\n\tstruct hv_pcibus_device *hbus = hv_get_drvdata(hdev);\n\tstruct pci_message message;\n\tstruct completion comp;\n\tint ret;\n\n\t/* Ask the host to send along the list of child devices */\n\tinit_completion(&comp);\n\tif (cmpxchg(&hbus->survey_event, NULL, &comp))\n\t\treturn -ENOTEMPTY;\n\n\tmemset(&message, 0, sizeof(message));\n\tmessage.type = PCI_QUERY_BUS_RELATIONS;\n\n\tret = vmbus_sendpacket(hdev->channel, &message, sizeof(message),\n\t\t\t       0, VM_PKT_DATA_INBAND, 0);\n\tif (!ret)\n\t\tret = wait_for_response(hdev, &comp);\n\n\treturn ret;\n}", "summary": "Ask host to send list of child devices"}
{"file_path": "/home/Downloads/project/homebrew/sqlcipher/src/backup.c", "function": "int sqlite3_backup_remaining(sqlite3_backup *p){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( p==0 ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n  return p->nRemaining;\n}", "summary": "Return the number of pages still to be backed up as of the most recent call to sqlite3_backup_step"}
{"file_path": "/home/Downloads/project/c-project/qemu/hw/pci/pcie.c", "function": "void pcie_cap_arifwd_init(PCIDevice *dev)\n{\n    uint32_t pos = dev->exp.exp_cap;\n    pci_long_test_and_set_mask(dev->config + pos + PCI_EXP_DEVCAP2,\n                               PCI_EXP_DEVCAP2_ARI);\n    pci_long_test_and_set_mask(dev->wmask + pos + PCI_EXP_DEVCTL2,\n                               PCI_EXP_DEVCTL2_ARI);\n}", "summary": "Alternative Routing ID Interpretation ARI forwarding support for root and downstream ports"}
{"file_path": "/home/Downloads/project/c-project/qemu/pc-bios/s390-ccw/dasd-ipl.c", "function": "static void check_ipl1(void)\n{\n    Ccw0 *ccwread = (Ccw0 *)0x08;\n    Ccw0 *ccwtic = (Ccw0 *)0x10;\n\n    if (ccwread->cmd_code != CCW_CMD_DASD_READ ||\n        ccwtic->cmd_code != CCW_CMD_TIC) {\n        panic(\"dasd-ipl: IPL1 data invalid. Is this disk really bootable?\\n\");\n    }\n}", "summary": "The architecture states that IPL1 data should consist of a psw followed by format 0 READ and TIC CCWs"}
