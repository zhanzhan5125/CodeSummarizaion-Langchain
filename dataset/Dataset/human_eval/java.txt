-----------------  idx: 0  -----------------
Code:
public CtorDescriptor getCtorDescriptor(final Class... args) {
		ctors:
		for (CtorDescriptor ctorDescriptor : allCtors) {
			Class[] arg = ctorDescriptor.getParameters();

			if (arg.length != args.length) {
				continue;
			}

			for (int j = 0; j < arg.length; j++) {
				if (arg[j] != args[j]) {
					continue ctors;
				}
			}

			return ctorDescriptor;
		}
		return null;
	}
Summary 1: Get constructor descriptor based on given argument types .
Summary 2: Searches for a constructor descriptor with the specified argument types in the list of all constructors .
Summary 3: Retrieves the constructor descriptor that matches the provided argument types .
Summary 4: Get constructor descriptor by argument types .
Summary 5: Finds constructor description that matches given argument types .

-----------------  idx: 1  -----------------
Code:
protected OPair<Direction, String> getConnection(final Direction iDirection, final String iFieldName, String... iClassNames) {
    if (iClassNames != null && iClassNames.length == 1 && iClassNames[0].equalsIgnoreCase("E"))
      // DEFAULT CLASS, TREAT IT AS NO CLASS/LABEL
      iClassNames = null;

    final OrientBaseGraph graph = getGraph();
    if (iDirection == Direction.OUT || iDirection == Direction.BOTH) {
      if (settings.isUseVertexFieldsForEdgeLabels()) {
        // FIELDS THAT STARTS WITH "out_"
        if (iFieldName.startsWith(CONNECTION_OUT_PREFIX)) {
          String connClass = getConnectionClass(Direction.OUT, iFieldName);
          if (iClassNames == null || iClassNames.length == 0)
            return new OPair<Direction, String>(Direction.OUT, connClass);

          // CHECK AGAINST ALL THE CLASS NAMES
          OrientEdgeType edgeType = graph.getEdgeType(connClass);
          if (edgeType != null) {
            for (String clsName : iClassNames) {
              if (edgeType.isSubClassOf(clsName))
                return new OPair<Direction, String>(Direction.OUT, connClass);
            }
          }
        }
      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_OUT))
        // CHECK FOR "out"
        return new OPair<Direction, String>(Direction.OUT, null);
    }

    if (iDirection == Direction.IN || iDirection == Direction.BOTH) {
      if (settings.isUseVertexFieldsForEdgeLabels()) {
        // FIELDS THAT STARTS WITH "in_"
        if (iFieldName.startsWith(CONNECTION_IN_PREFIX)) {
          String connClass = getConnectionClass(Direction.IN, iFieldName);
          if (iClassNames == null || iClassNames.length == 0)
            return new OPair<Direction, String>(Direction.IN, connClass);

          // CHECK AGAINST ALL THE CLASS NAMES
          OrientEdgeType edgeType = graph.getEdgeType(connClass);
          if (edgeType != null) {
            for (String clsName : iClassNames) {
              if (edgeType.isSubClassOf(clsName))
                return new OPair<Direction, String>(Direction.IN, connClass);
            }
          }
        }
      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_IN))
        // CHECK FOR "in"
        return new OPair<Direction, String>(Direction.IN, null);
    }

    // NOT FOUND
    return null;
  }
Summary 1: Determines the connection type and class name for a given direction and field name, considering inheritance among edge classes in an OrientDB graph .
Summary 2: Determines if a field is a connections or not .
Summary 3: Get the connection details based on the provided direction and field name, along with optional class names .
Summary 4: This method determines the connection type (either "out" or "in") and the class name of the edge that is associated with a given field name and class names .
Summary 5: Get connection information .

-----------------  idx: 2  -----------------
Code:
static public ArrayStructureMA factoryMA(Structure from, int[] shape) throws IOException {
    StructureMembers sm = from.makeStructureMembers();
    for (Variable v : from.getVariables()) {
      Array data;
      if (v instanceof Sequence) {
        data = Array.factory(DataType.SEQUENCE, shape);  // an array sequence - one for each parent element
        //Structure s = (Structure) v;
        //StructureMembers smn = s.makeStructureMembers();
        // data = new ArraySequenceNested(smn, (int) Index.computeSize(v.getShapeAll())); // ??

      } else if (v instanceof Structure)
        data = ArrayStructureMA.factoryMA((Structure) v, combine(shape, v.getShape()));

      else
        data = Array.factory(v.getDataType(), combine(shape, v.getShape()));

      StructureMembers.Member m = sm.findMember(v.getShortName());
      m.setDataArray(data);
    }

    return new ArrayStructureMA(sm, shape);
  }
Summary 1: Create an ArrayStructure for a Structure . Allow nested Structures . Create the data arrays and an iterator .
Summary 2: Creates an ArrayStructureMA with a specified shape based on data from an existing Structure .
Summary 3: Creates a multidimensional array structure with given shape from a structure object, setting data arrays for each variable .
Summary 4: Create a multidimensional array structure from a sequence or structure, with the specified shape .
Summary 5: Create a new ArrayStructureMA with the given shape, using the Variable and DataType information from the given Structure .

-----------------  idx: 3  -----------------
Code:
public DDS getDDS(String CE) throws IOException, ParseException, DAP2Exception
    {
        DDSCommand command = new DDSCommand();
        command.setURL(CE == null || CE.length() == 0 ? urlString : urlString + "?" + CE);
        if(filePath != null) {
            try (FileInputStream is = new FileInputStream(filePath + ".dds")) {
                command.process(is);
            }
        } else if(stream != null) {
            command.process(stream);
        } else { // must be a remote url
            openConnection(urlString + ".dds" + (getCompleteCE(CE)), command);
        }
        return command.dds;
    }
Summary 1: Retrieve DDS (Data Descriptor Structure) from a specified URL, file path, or input stream .
Summary 2: Returns the DDS object from the dataset referenced by this object s URL . The DDS object is referred to by appending . dds to the end of a OPeNDAP URL .
Summary 3: Get DDS (Dataset Description Section) from a URL or file, using the specified CE (Constraint Expression) to filter the data .
Summary 4: Get a DDS object from a CE .
Summary 5: Retrieves the Data Descriptor Structure (DDS) for a given Constraint Expression (CE) from a file, stream, or URL .

-----------------  idx: 4  -----------------
Code:
static boolean
  urlMatch(URL pattern, URL url) {
    int relation;

    if (pattern == null)
      return (url == null);

    if (!(url.getHost().endsWith(pattern.getHost())))
      return false; // e.g. pattern=x.y.org url=y.org

    if (!(url.getPath().startsWith(pattern.getPath())))
      return false; // e.g. pattern=y.org/a/b url=y.org/a

    if (pattern.getPort() > 0 && pattern.getPort() != url.getPort())
      return false;

    // note: all other fields are ignored

    return true;
  }
Summary 1: Checks if a URL matches a given pattern by comparing the host, path, and port .
Summary 2: Match has different semantics than urlCompare
Summary 3: Determines whether a URL matches another URL .
Summary 4: Check if the URL matches the given pattern by comparing the host, path, and port .
Summary 5: Checks if the provided URL matches the specified pattern URL, considering host, path, and port .

-----------------  idx: 5  -----------------
Code:
protected void retryTimeout(TimerImpl timer) throws Exception {
        boolean callTimeout = false;

        timer.lock();
        try {
            if (timer.isActive()) {
                EJB3_TIMER_LOGGER.retryingTimeout(timer);
                timer.setTimerState(TimerState.RETRY_TIMEOUT, Thread.currentThread());
                timerService.persistTimer(timer, false);
                callTimeout = true;
            } else {
                EJB3_TIMER_LOGGER.timerNotActive(timer);
            }
        } finally {
            timer.unlock();
        }
        if(callTimeout) {
            this.callTimeout(timer);
        }
    }
Summary 1: Handles retry logic for timed out EJB timers, executing the timeout if the timer is still active .
Summary 2: Retry the timer if it is still active, otherwise log a warning .
Summary 3: Retries the timeout of a timer if it is active, and calls the timeout method if retry is successful .
Summary 4: Retry the given timer if it is active .
Summary 5: After a timeout failed the timer need to retried . The method must lock the timer for state check and update but not during callTimeout run .

-----------------  idx: 6  -----------------
Code:
static private boolean isInsideCharClass(String s, int pos) {

        boolean openBracketFound = false;
        boolean closeBracketFound = false;

        // find last non-escaped open-bracket
        String s2 = s.substring(0, pos);
        int posOpen = pos;
        while ((posOpen = s2.lastIndexOf('[', posOpen - 1)) != -1) {
            if (!isEscapedChar(s2, posOpen)) {
                openBracketFound = true;
                break;
            }
        }

        if (openBracketFound) {
            // search remainder of string (after open-bracket) for a close-bracket
            String s3 = s.substring(posOpen, pos);
            int posClose = -1;
            while ((posClose = s3.indexOf(']', posClose + 1)) != -1) {
                if (!isEscapedChar(s3, posClose)) {
                    closeBracketFound = true;
                    break;
                }
            }
        }

        return openBracketFound && !closeBracketFound;
    }
Summary 1: Checks if a character is inside a character class .
Summary 2: Determines if a string s character is within a regex character class
Summary 3: Checks if the given position within the string is inside an unescaped character class in a regex .
Summary 4: Check if the character at position `pos` in the string `s` is inside a character class, i.e .
Summary 5: Checks if the current position in a string is inside a character class that has an open bracket but no corresponding closing bracket .

-----------------  idx: 7  -----------------
Code:
private static String getCellFontDecoration(final Font font) {
		StringBuilder decoration = new StringBuilder();
		if (font.getUnderline() != 0) {
			decoration.append(" underline");
		}
		if (font.getStrikeout()) {
			decoration.append(" line-through");
		}
		return decoration.toString();
	}
Summary 1: Get the font decoration (underline or line-through) from the given font object .
Summary 2: Get CSS font decoration from JavaFX Font .
Summary 3: Returns the font decoration for a given font, including "underline" if the font has underline and "line-through" if the font has strikeout .
Summary 4: Get font decoration .
Summary 5: Generates a string representing the CSS font decoration based on underline and strikeout properties of a given font .

-----------------  idx: 8  -----------------
Code:
public Q setMap(final Map parameters) {
		if (parameters == null) {
			return _this();
		}
		init();
		query.forEachNamedParameter(p -> {
			final String paramName = p.name;
			setObject(paramName, parameters.get(paramName));
		});
		return _this();
	}
Summary 1: Sets the query parameters using the provided map, returning the updated query builder object .
Summary 2: Sets the value of a named parameter in the query .
Summary 3: Set the map of parameters for the query, initializing and setting values for each named parameter if available .
Summary 4: Sets properties from the map .
Summary 5: Set the query parameters from a map .

-----------------  idx: 9  -----------------
Code:
public static int hash(Object key[], FieldType fieldType[]) {
        int hash = 0;

        for (int i = 0; i < key.length; i++) {
            hash *= 31;
            hash ^= hash(key[i], fieldType[i]);
        }

        return hash;
    }
Summary 1: Generates a composite hash code for an array of keys based on their respective field types .
Summary 2: Hash a key
Summary 3: Computes a hash value based on an array of keys and corresponding field types .
Summary 4: Generate a hash code for an array of objects .
Summary 5: Calculate a hash code for the given key and field types .

-----------------  idx: 10  -----------------
Code:
public void startUnbounded() {
        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {
            queue = new SpscLinkedArrayQueue<T>(bufferSize);
        }
    }
Summary 1: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
Summary 2: Start unbounded data stream .
Summary 3: Set the upstream Subscription to EmptySubscription.INSTANCE and create a new SpscLinkedArrayQueue with the specified bufferSize .
Summary 4: Starts an unbounded subscription by initializing the queue .
Summary 5: Initializes an unbounded reactive queue if an upstream subscription is successfully set once .

-----------------  idx: 11  -----------------
Code:
public PerfAsyncConsumer await(int count) {
        if (count <= 1000) {
            while (getCount() != 0) { }
        } else {
            try {
                await();
            } catch (InterruptedException ex) {
                throw new RuntimeException(ex);
            }
        }
        return this;
    }
Summary 1: Await for the specified number of events to be processed, or wait indefinitely if the count is greater than 1000 .
Summary 2: Wait for the terminal signal .
Summary 3: Waits synchronously until the count is zero, using busy-wait for counts less than or equal to 1000, or a blocking wait for higher counts .
Summary 4: Waits for a specified count of asynchronous operations to complete before continuing execution .
Summary 5: Wait for the specified number of items to be processed .

-----------------  idx: 12  -----------------
Code:
private void setPeople(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException {
		msgToSet.setFrom(emailWithData.from().toInternetAddress());
		msgToSet.setReplyTo(EmailAddress.convert(emailWithData.replyTo()));
		setRecipients(emailWithData, msgToSet);
	}
Summary 1: Sets the To, Cc, and Bcc recipients for an email .
Summary 2: Set the "from" and "reply-to" fields of the email message .
Summary 3: Sets FROM REPLY - TO and recipients .
Summary 4: Sets the sender, reply-to address, and recipients on a MimeMessage using data from an Email object .
Summary 5: Sets the sender, reply-to, and recipients of the email message .

-----------------  idx: 13  -----------------
Code:
public static String title(final String string) {
		char[] chars = string.toCharArray();
		
		boolean wasWhitespace = true;
		
		for (int i = 0; i < chars.length; i++) {
			char c = chars[i];
			
			if (CharUtil.isWhitespace(c)) {
				wasWhitespace = true;
			} else {
				if (wasWhitespace) {
					chars[i] = Character.toUpperCase(c);
				} else {
					chars[i] = Character.toLowerCase(c);
				}
				wasWhitespace = false;
			}
		}
		
		return new String(chars);
	}
Summary 1: Convert a string to title case .
Summary 2: Returns a title case version of the input string .
Summary 3: Makes a title - cased string from given input .
Summary 4: Convert a string to title case, where the first letter of each word is capitalized and the rest are lowercase .
Summary 5: Converts the first letter of each word in a string to uppercase and the rest to lowercase .

-----------------  idx: 14  -----------------
Code:
@Override
	@SuppressWarnings({"ClassReferencesSubclass"})
	public void close() {
		final SQLException sqlException = closeQuery();
		connection = null;
		if (this.session != null) {
			this.session.detachQuery(this);
		}
		if (sqlException != null) {
			throw new DbSqlException("Close query error", sqlException);
		}
	}
Summary 1: Close the query and detach it from the session, throwing a DbSqlException if there was an error closing the query .
Summary 2: Closes the query and all created results sets and detaches itself from the session .
Summary 3: Closes the query and detaches it from the session, throwing an exception if there was an error .
Summary 4: Closes the query, detaches from session, and throws `DbSqlException` on `SQLException` during close .
Summary 5: Close the query and release the connection .

-----------------  idx: 15  -----------------
Code:
public void doSubmit() {
				
		this.setSubmitMde(true);
		// validation may behavior differently depend on the submit mode.
		// e.g. when submit mode = false, empty fields or value not changed cells
		// don't need to pass the validation rule. This allow partial save the form. 
		// when submit mode = true, all cells need to pass the validation.
		if (!this.getHelper().getValidationHandler().preValidation()) {
			LOG.fine("Validation failed before saving");
			return;
		}
		processSubmit();
		this.getHelper().getWebSheetLoader().setUnsavedStatus(
				RequestContext.getCurrentInstance(), false);
		this.setSubmitMde(false);
	}
Summary 1: Submit the current workbooks .
Summary 2: Performs form submission with validation checks and updates the web sheet loader status .
Summary 3: This method submits the form data to the server for processing .
Summary 4: Handles the form submission process, including validation and updating the unsaved status .
Summary 5: Submits the form .

-----------------  idx: 16  -----------------
Code:
protected Element createElementNode(final Tag tag) {
		boolean hasVoidTags = htmlVoidRules != null;

		boolean isVoid = false;
		boolean selfClosed = false;

		if (hasVoidTags) {
			isVoid = htmlVoidRules.isVoidTag(tag.getName());

			// HTML and XHTML
			if (isVoid) {
				// it's void tag, lookup the flag
				selfClosed = domBuilder.config.isSelfCloseVoidTags();
			}
		} else {
			// XML, no voids, lookup the flag
			selfClosed = domBuilder.config.isSelfCloseVoidTags();
		}

		return new Element(rootNode, tag, isVoid, selfClosed);
	}
Summary 1: Creates new element with correct configuration .
Summary 2: Create a new element node with the specified tag, and set its void and self-closed properties based on the HTML void rules and the configuration of the DOM builder .
Summary 3: Create an HTML element node .
Summary 4: Creates a new Element node, determining its void and self-closing properties based on configuration and HTML void tag rules .
Summary 5: Creates a new element node based on the given tag, considering void tag rules and self-closing options .

-----------------  idx: 17  -----------------
Code:
public void setLongId(P pojo, Long id) {
		if (!clazz.isAssignableFrom(pojo.getClass()))
			throw new IllegalArgumentException("Trying to use metadata for " + clazz.getName() + " to set key of " + pojo.getClass().getName());

		this.idMeta.getProperty().set(pojo, id);
	}
Summary 1: Set the long id of a pojo using the metadata for the class of the pojo .
Summary 2: Sets the identifier of a provided object if it matches the expected type, throwing an exception otherwise .
Summary 3: Set the long identifier for a given POJO object, using metadata .
Summary 4: Sets the numeric id field
Summary 5: Set the id of an entity .

-----------------  idx: 18  -----------------
Code:
private void createWebAppDescriptor(final Deployment dep, final JBossWebMetaData jbossWebMD) {
        WSLogger.ROOT_LOGGER.trace("Creating web.xml descriptor");
        createServlets(dep, jbossWebMD);
        createServletMappings(dep, jbossWebMD);
        createSecurityConstraints(dep, jbossWebMD);
        createLoginConfig(dep, jbossWebMD);
        createSecurityRoles(dep, jbossWebMD);
    }
Summary 1: Create a web.xml descriptor for the deployment .
Summary 2: Creates web . xml descriptor meta data .
Summary 3: Creates a web.xml descriptor for a web application, including servlets, servlet mappings, security constraints, login configuration, and security roles .
Summary 4: Create web.xml descriptor .
Summary 5: Constructs the web.xml descriptor for a deployment by setting up servlets, mappings, security constraints, login configuration, and security roles .

-----------------  idx: 19  -----------------
Code:
public void connectionLost() {
        // Ensure that only one thread will try to reconnect.
        synchronized (this) {
            if (reconnecting) {
                return;
            }
            reconnecting = true;
        }
        readerThread = null;
        boolean isConnected = false;
        if (!shutdown) {
            // Notify the component that connection was lost so it needs to
            // shutdown. The component is
            // still registered in the local component manager but just not
            // connected to the server
            component.shutdown();
        }
        while (!isConnected && !shutdown) {
            try {
                connect(host, port, subdomain);
                isConnected = true;
                // It may be possible that while a new connection was being
                // established the
                // component was required to shutdown so in this case we need to
                // close the new
                // connection
                if (shutdown) {
                    disconnect();
                } else {
                    // Component is back again working so start it up again
                    start();
                }
            } catch (ComponentException e) {
                manager.getLog().error(
                        "Error trying to reconnect with the server", e);
                // Wait for 5 seconds until the next retry
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e1) {
                    // Do nothing
                }
            }
        }
        reconnecting = false;
    }
Summary 1: Notification message that the connection with the server was lost unexpectedly . We will try to reestablish the connection for ever until the connection has been reestablished or this thread has been stopped .
Summary 2: Handles connection loss and attempts to reconnect with the server in a loop until a successful connection is established or shutdown is initiated .
Summary 3: This function attempts to reconnect with the server if the connection is lost .
Summary 4: Handles lost connection by attempting to reconnect to the server, with automatic retries every 5 seconds until successful or shutdown .
Summary 5: Reconnects to the server if the connection is lost .

-----------------  idx: 20  -----------------
Code:
public static boolean isErrorAndSendException(ResultSender<Object> resultSender, Object data)
	{
		if(data instanceof Throwable)
		{
			Throwable e = (Throwable)data;			
			
			resultSender.sendException(e);
			return true;
		}
		
		return false;
	}
Summary 1: Check if data is an exception and send it to the result sender .
Summary 2: Checks if the data is an error (Throwable) and sends it as an exception using the ResultSender .
Summary 3: Check if the given data is an instance of Throwable and if so, send it as an exception to the result sender .
Summary 4: Checks if data is an exception and sends it through the result sender if so .
Summary 5: Determine if the data should be sent

-----------------  idx: 21  -----------------
Code:
protected void rollbackAllResources(final boolean wasForced) {
		status = STATUS_ROLLING_BACK;
		Exception lastException = null;
		Iterator<JtxResource> it = resources.iterator();
		while (it.hasNext()) {
			JtxResource resource = it.next();
			try {
				resource.rollbackTransaction();
			} catch (Exception ex) {
				lastException = ex;
			} finally {
				it.remove();
			}
		}
		txManager.removeTransaction(this);
		status = STATUS_ROLLEDBACK;
		if (lastException != null) {
			status = STATUS_UNKNOWN;
			throw new JtxException("Rollback failed: one or more TX resources couldn't rollback a TX", lastException);
		}
		if (wasForced) {
			throw new JtxException("TX rolled back because it has been marked as rollback-only", rollbackCause);
		}
	}
Summary 1: Rolls back all transaction resources and updates the status accordingly .
Summary 2: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
Summary 3: Rollback all resources and remove the transaction from the transaction manager .
Summary 4: Rolls back all associated resources of a transaction and updates the transaction's status .
Summary 5: Rollback all resources in the transaction, marking the transaction as rolled back and throwing an exception if any of the resources failed to rollback .

-----------------  idx: 22  -----------------
Code:
public static String parseSocketAddressToHostIp(SocketAddress socketAddress) {
        final InetSocketAddress addrs = (InetSocketAddress) socketAddress;
        if (addrs != null) {
            InetAddress addr = addrs.getAddress();
            if (null != addr) {
                return addr.getHostAddress();
            }
        }
        return StringUtils.EMPTY;
    }
Summary 1: Parse the host ip of socket address .
Summary 2: Parses a socket address to extract the host IP address .
Summary 3: Parses a SocketAddress and returns the corresponding host IP address .
Summary 4: Extracts and returns the host IP address from a SocketAddress, or returns an empty string if not available .
Summary 5: Parse the given socket address to extract the host IP address .

-----------------  idx: 23  -----------------
Code:
public static ChartType getChartType(final CTChart ctChart) {
        CTPlotArea plotArea = ctChart.getPlotArea();

        for (ChartType chartType : ChartType.values()) {
            if (chartType.isThisType(plotArea)) {
                return chartType;
            }
        }
        return null;
    }
Summary 1: Determines the type of chart from the given CTChart's plot area .
Summary 2: Get the chart type from the given CTChart object .
Summary 3: return chart type from CTChart object .
Summary 4: Determine the type of chart from the plot area of the chart template by iterating over the available chart types and returning the first one that matches the plot area .
Summary 5: Get the type of chart based on the plot area .

-----------------  idx: 24  -----------------
Code:
public long appendPadding(final int length)
    {
        checkMaxMessageLength(length);
        long newPosition = CLOSED;

        if (!isClosed)
        {
            final long limit = positionLimit.getVolatile();
            final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex];
            final long position = termBeginPosition + termOffset;

            if (position < limit)
            {
                checkPositiveLength(length);
                final int result = termAppender.appendPadding(termId, termOffset, headerWriter, length);
                newPosition = newPosition(result);
            }
            else
            {
                newPosition = backPressureStatus(position, length);
            }
        }

        return newPosition;
    }
Summary 1: Append a padding record log of a given length to make up the log to a position .
Summary 2: Append a padding message to the log with the specified length .
Summary 3: Append padding to the end of the log .
Summary 4: Appends padding to the current term if possible, while checking for message length and channel closed status .
Summary 5: Append padding to a message with a given length, considering message length limits and back pressure status .

-----------------  idx: 25  -----------------
Code:
public SnapshotRecord readSnapshotRecord() throws IOException, ClassNotFoundException {
      byte[] key = DataSerializer.readByteArray(dis);
      if (key == null) {
        return null;
      }

      byte[] value = DataSerializer.readByteArray(dis);
      return new SnapshotRecord(key, value);
    }
Summary 1: Reads a snapshot record from the input stream, returning null if the end of the stream has been reached .
Summary 2: Reads a snapshot record from an input stream, returning a new `SnapshotRecord` object or `null` if the key is not present .
Summary 3: Read a snapshot record from the input stream .
Summary 4: Reads a snapshot entry . If the last entry has been read a null value will be returned .
Summary 5: Reads a SnapshotRecord from input, including key and value data .

-----------------  idx: 26  -----------------
Code:
public boolean add(final Object obj) {
      maintain();

      SoftObject soft = SoftObject.create(obj, queue);
      
      return collection.add(soft);
   }
Summary 1: Add an object to the collection .
Summary 2: Add an object to the collection .
Summary 3: Add an object to the collection, maintaining the soft reference queue .
Summary 4: Adds an object to the collection, using a soft reference .
Summary 5: Adds a softly-referenced object to the collection, cleaning up any garbage-collected references in the process .

-----------------  idx: 27  -----------------
Code:
public InetSocketAddress receive(final ByteBuffer buffer)
    {
        buffer.clear();

        InetSocketAddress address = null;
        try
        {
            if (receiveDatagramChannel.isOpen())
            {
                address = (InetSocketAddress)receiveDatagramChannel.receive(buffer);
            }
        }
        catch (final PortUnreachableException ignored)
        {
        }
        catch (final Exception ex)
        {
            LangUtil.rethrowUnchecked(ex);
        }

        return address;
    }
Summary 1: Receives data into a ByteBuffer from a DatagramChannel and returns the source address .
Summary 2: Receive a datagram from the media layer .
Summary 3: Receive a datagram packet from the socket and store it in the provided buffer .
Summary 4: Receives a datagram from the socket .
Summary 5: Receives a packet into the provided ByteBuffer and returns the sender's address, ignoring PortUnreachableException .

-----------------  idx: 28  -----------------
Code:
public Float getFloat(final String key) {
		Number number = (Number) map.get(key);

		if (number == null) {
			return null;
		}
		if (number instanceof Float) {
			return (Float) number;
		}
		return number.floatValue();
	}
Summary 1: Get the float value associated with the given key in the map, or convert it to float if it is a number .
Summary 2: Retrieves the value mapped to the given key as a floating-point number, auto-boxing the number to a Float if necessary .
Summary 3: Get the float value associated with the given key in the map .
Summary 4: Returns the float value with the specified key .
Summary 5: Get float value from map .

-----------------  idx: 29  -----------------
Code:
@Urlencoded
  @Deprecated
  public static String getContentAsString(HTTPSession session, String urlencoded) throws IOException
  {
    HTTPSession useSession = session;
    try {
      if (useSession == null)
        useSession = HTTPFactory.newSession(urlencoded);
      try (HTTPMethod m = HTTPFactory.Get(useSession, urlencoded)) {
          m.execute();
          return m.getResponseAsString();
      }
    } finally {
      if ((session == null) && (useSession != null))
        useSession.close();
    }
  }
Summary 1: Get the content of a URL encoded string .
Summary 2: This method retrieves the content of a URL as a string, using the specified HTTPSession and URL .
Summary 3: Retrieves the content of a URL-encoded string as a string, using a provided HTTPSession, or creating a new one if none is provided .
Summary 4: Get the content from a url . For large returns its better to use getResponseAsStream .
Summary 5: Get content of a URL and return it as a string, handling URL encoding and deprecated annotations .

-----------------  idx: 30  -----------------
Code:
protected void createEntries(final MutableAcl acl) {
		if (acl.getEntries().isEmpty()) {
			return;
		}
		jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() {
			public int getBatchSize() {
				return acl.getEntries().size();
			}

			public void setValues(PreparedStatement stmt, int i) throws SQLException {
				AccessControlEntry entry_ = acl.getEntries().get(i);
				Assert.isTrue(entry_ instanceof AccessControlEntryImpl,
						"Unknown ACE class");
				AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_;

				stmt.setLong(1, ((Long) acl.getId()).longValue());
				stmt.setInt(2, i);
				stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true)
						.longValue());
				stmt.setInt(4, entry.getPermission().getMask());
				stmt.setBoolean(5, entry.isGranting());
				stmt.setBoolean(6, entry.isAuditSuccess());
				stmt.setBoolean(7, entry.isAuditFailure());
			}
		});
	}
Summary 1: Batch inserts ACL entries into the database .
Summary 2: Create entries for a MutableAcl by batch updating a SQL statement with values from the entries in the ACL .
Summary 3: Create entries in database .
Summary 4: Saves ACL entries in batch to the database if any exist .
Summary 5: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

-----------------  idx: 31  -----------------
Code:
private void doAdditionalRead() throws InterruptedException, IOException {
		WebSocketImpl conn;
		while ( !iqueue.isEmpty() ) {
			conn = iqueue.remove( 0 );
			WrappedByteChannel c = ( (WrappedByteChannel) conn.getChannel() );
			ByteBuffer buf = takeBuffer();
			try {
				if( SocketChannelIOHelper.readMore( buf, conn, c ) )
					iqueue.add( conn );
				if( buf.hasRemaining() ) {
					conn.inQueue.put( buf );
					queue( conn );
				} else {
					pushBuffer( buf );
				}
			} catch ( IOException e ) {
				pushBuffer( buf );
				throw e;
			}
		}
	}
Summary 1: Reads data from the underlying socket connections .
Summary 2: Do an additional read
Summary 3: Reads data from the input queue and writes it to the output queue, using the WebSocket protocol to fragment the data into multiple messages if necessary .
Summary 4: Performs additional read operations for WebSocket connections, continuously processing data from the input queue until it is empty .
Summary 5: Processes additional reads for each WebSocket connection in the input queue, re-queuing them if more data is available .

-----------------  idx: 32  -----------------
Code:
int pcode_12n13n14( int[] pos, int[] dlen, int hoff, int len, boolean isZ, String structName, int code )
    {
       //int vlen = len;

        int vlen = 0;
        for(int i=0; i<len; i++ ){
           vlen = vlen + dlen[i];
        }

        ArrayList dims =  new ArrayList();
        Dimension sDim = new Dimension("graphicSymbolSize", vlen);
        ncfile.addDimension( null, sDim);
        dims.add( sDim);

        Structure dist = new Structure(ncfile, null, null, structName);
        dist.setDimensions(dims);
        ncfile.addVariable(null, dist);
        dist.addAttribute( new Attribute(CDM.LONG_NAME, "special graphic symbol for code "+code));


        Variable i0 = new Variable(ncfile, null, dist, "x_start");
        i0.setDimensions((String)null);
        i0.setDataType(DataType.FLOAT);
        i0.addAttribute( new Attribute(CDM.UNITS, "KM"));
        dist.addMemberVariable(i0);
        Variable j0 = new Variable(ncfile, null, dist, "y_start");
        j0.setDimensions((String)null);
        j0.setDataType(DataType.FLOAT);
        j0.addAttribute( new Attribute(CDM.UNITS, "KM"));
        dist.addMemberVariable(j0);


       int[] pos1 = new int[len];
       int[] dlen1 = new int[len];
       System.arraycopy(dlen, 0, dlen1, 0, len);
       System.arraycopy(pos, 0, pos1, 0, len);
       dist.setSPobject( new Vinfo ( 0, 0, 0, 0, hoff, 0, isR, isZ, pos1, dlen1, code, 0));
       return 1;
     }
Summary 1: Defines a new Structure for special graphic symbols associated with a specific code in a NetCDF file .
Summary 2: This function creates a netcdf file with a variable that contains the binary representation of a special graphic symbol .
Summary 3: This function creates a new NetCDF variable with the specified name and adds it to the NetCDF file .
Summary 4: construct a dataset for special graphic symbol packet with code 12 13 and 14
Summary 5: Create a special graphic symbol structure with given dimensions, attributes, and member variables, and add it to the netCDF file .

-----------------  idx: 33  -----------------
Code:
public java.util.Collection<AudioFormat.Type>
  getSupportedAudioFormats()
  {
    java.util.List<AudioFormat.Type> retval =
      new java.util.LinkedList<AudioFormat.Type>();
    int count = getNumSupportedAudioFormats();
    for(int i=0;i<count;i++)
    {
      AudioFormat.Type fmt = getSupportedAudioFormat(i);
      if (fmt != null && fmt != AudioFormat.Type.SAMPLE_FMT_NONE)
        retval.add(fmt);
    }
    return retval;
  }
Summary 1: Get a list of supported audio formats .
Summary 2: Returns a collection of supported audio formats by querying the number of supported formats and then adding the formats to the collection .
Summary 3: Returns a list of supported audio sample formats this codec can encode audio in .
Summary 4: Returns a collection of supported audio formats by iterating through the available formats and adding them to the list .
Summary 5: Returns a collection of supported audio formats by iterating through the available formats and excluding unsupported or undefined types .

-----------------  idx: 34  -----------------
Code:
@SuppressWarnings("unchecked")
    public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E {
        if (e instanceof Exception) {
            return (Exception)e;
        }
        throw (E)e;
    }
Summary 1: This method takes a Throwable object and throws it as an Exception if it is an instance of Exception, or throws it as a different type of exception if it is not an instance of Exception .
Summary 2: Throws the throwable as an exception if it is not already an exception .
Summary 3: Re-throws a Throwable as an unchecked exception if it's not already an Exception .
Summary 4: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
Summary 5: Check if the given Throwable is an instance of Exception and if so, return it .

-----------------  idx: 35  -----------------
Code:
private void gatherTasksOptions(TaskFactory taskFactory, Options options) {
        for (Task task : taskFactory.getTasks()) {
            for (Option option : task.getOptions()) {
                options.addOption(option);
            }
        }
    }
Summary 1: Gather all options from all tasks in the task factory and add them to the options object .
Summary 2: Collects and adds options from all tasks provided by a task factory into a single Options object .
Summary 3: Gathers options from tasks and adds them to a common options object .
Summary 4: Gathers the task specific options for all tasks .
Summary 5: Gather task options .

-----------------  idx: 36  -----------------
Code:
protected void doDeploy(ServiceTarget target, DeploymentUnit unit) {
        List<DeploymentAspect> aspects = getDeploymentAspects();
        ClassLoader origClassLoader = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();
        Deployment dep = null;
        try {
            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader());
            dep = unit.getAttachment(WSAttachmentKeys.DEPLOYMENT_KEY);
            dep.addAttachment(ServiceTarget.class, target);
            DeploymentAspectManager dam = new DeploymentAspectManagerImpl();
            dam.setDeploymentAspects(aspects);
            dam.deploy(dep);
        } finally {
            if (dep != null) {
                dep.removeAttachment(ServiceTarget.class);
            }
            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(origClassLoader);
        }
    }
Summary 1: Deploys a deployment unit with the given aspects and sets the service target before deploying .
Summary 2: Triggers the WS deployment aspects which process the deployment and install the endpoint services .
Summary 3: Deploys the service .
Summary 4: Executes deployment of a service with aspects management and context class loader handling .
Summary 5: This method is responsible for deploying a deployment unit to a service target .

-----------------  idx: 37  -----------------
Code:
public Array readIntData(LayoutRegular index, Variable v2) throws IOException {
    int[] var = (int[]) (v2.read().get1DJavaArray(v2.getDataType()));
    int[] data = new int[(int) index.getTotalNelems()];
    while (index.hasNext()) {
      Layout.Chunk chunk = index.next();
      System.arraycopy(var, (int) chunk.getSrcPos() / 4, data, (int) chunk.getDestElem(), chunk.getNelems());
    }
    return Array.factory(v2.getDataType(), new int[] {(int) index.getTotalNelems()}, data);
  }
Summary 1: Reads integer data from a variable using a given layout and returns an array .
Summary 2: Reads integer data from a variable in a netCDF file, using a regular layout .
Summary 3: Read integer data from a netcdf file .
Summary 4: Reads and returns an integer array from a specified variable using a regular layout defined by `index` .
Summary 5: Read data from a top level Variable of INTEGER data type and return a memory resident Array .

-----------------  idx: 38  -----------------
Code:
public StyledLayerDescriptorInfo toSldI(RawSld sld) throws SldException {
		try {
			return parseXml(sld.getName(), sld.getXml());
		} catch (JiBXException e) {
			throw new SldException("Validation error", e);
		}
	}
Summary 1: Converts a RawSld object to a StyledLayerDescriptorInfo object by parsing the XML and handling any validation errors .
Summary 2: Parses the XML of a raw SLD (Styled Layer Descriptor) and converts it to a StyledLayerDescriptorInfo object, throwing an SldException on parse error .
Summary 3: Converts RawSld to StyledLayerDescriptorInfo .
Summary 4: Convert raw xml to StyledLayerDescriptorInfo .
Summary 5: Parse the given RawSld object into a StyledLayerDescriptorInfo object .

-----------------  idx: 39  -----------------
Code:
private Belief getResultAtIndex(Set<Belief> results, int index) {
    Belief belief = null;
    if (!(results == null || index < 0 || index >= results.size())) {
      int idx = 0;
      for (Belief b : results) {
        if (idx == index) {
          belief = b;
          break;
        }
        idx++;
      }
    }
    return belief;
  }
Summary 1: Get the belief at the specified index in the results set, or null if the index is out of bounds .
Summary 2: Get the belief at a specific index from a set of beliefs .
Summary 3: Retrieves the Belief object at the specified index within the results set, if the index is valid .
Summary 4: Gets the result at the given index from the results set .
Summary 5: Get the result at the specified index from a set of results .

-----------------  idx: 40  -----------------
Code:
public void awaitSuccessfulCompletionOfCurrentTasks() throws InterruptedException, ExecutionException {
        for(Future<?> f : futures) {
            f.get();
        }

        futures.clear();
    }
Summary 1: Wait for all tasks in the list of futures to complete successfully, clearing the list of futures after they have completed .
Summary 2: Wait for all tasks to complete .
Summary 3: Wait for all currently running tasks to complete successfully and clear the list of futures .
Summary 4: Waits for all submitted tasks to complete successfully and clears the future tasks list .
Summary 5: Await successful completion of all previously submitted tasks . Throw exception of the first failed task if 1 or more tasks failed .

-----------------  idx: 41  -----------------
Code:
private int getPort() {
		int port = uri.getPort();
		if( port == -1 ) {
			String scheme = uri.getScheme();
			if( "wss".equals( scheme ) ) {
				return WebSocketImpl.DEFAULT_WSS_PORT;
			} else if(  "ws".equals( scheme ) ) {
				return WebSocketImpl.DEFAULT_PORT;
			} else {
				throw new IllegalArgumentException( "unknown scheme: " + scheme );
			}
		}
		return port;
	}
Summary 1: Get port from URI .
Summary 2: Get the port number from the given URI, returns the default port if the port is not specified in the URI .
Summary 3: Get the port number from the URI, using the default port number for the scheme if the port number is not specified .
Summary 4: Retrieves the WebSocket port from a given URI, or defaults to standard ports for ws/wss schemes if none specified .
Summary 5: Extract the specified port

-----------------  idx: 42  -----------------
Code:
void okcolors(Nfa nfa) {
        ColorDesc cd;
        ColorDesc scd;
        Arc a;
        short sco;

        for (short co = 0; co < colorDescs.size(); co++) {
            cd = colorDescs.get(co);
            if (cd == null) {
                continue; // not in use at all, so can't have a subcolor.
            }

            sco = cd.sub;

            if (sco == Constants.NOSUB) {
            /* has no subcolor, no further action */
            } else if (sco == co) {
            /* is subcolor, let parent deal with it */
            } else if (cd.getNChars() == 0) {
            /* parent empty, its arcs change color to subcolor */
                cd.sub = Constants.NOSUB;
                scd = colorDescs.get(sco);

                assert scd.getNChars() > 0;
                assert scd.sub == sco;

                scd.sub = Constants.NOSUB;
                while ((a = cd.arcs) != null) {
                    assert a.co == co;
                    cd.arcs = a.colorchain;
                    a.setColor(sco);
                    a.colorchain = scd.arcs;
                    scd.arcs = a;
                }
                freecolor(co);
            } else {
                /* parent's arcs must gain parallel subcolor arcs */
                cd.sub = Constants.NOSUB;
                scd = colorDescs.get(sco);

                assert scd.getNChars() > 0;
                assert scd.sub == sco;

                scd.sub = Constants.NOSUB;

                for (a = cd.arcs; a != null; a = a.colorchain) {
                    assert a.co == co;
                    nfa.newarc(a.type, sco, a.from, a.to);
                }
            }
        }
    }
Summary 1: okcolors - promote subcolors to full colors
Summary 2: This function checks the colors of the NFA and sets the colors of the arcs accordingly .
Summary 3: This function is used to optimize the NFA for the DFA minimization algorithm .
Summary 4: Updates the colors of arcs in an NFA based on certain conditions and relationships between color descriptors .
Summary 5: This function optimizes and cleans up NFA color descriptors by merging redundant colors and removing empty descriptors .

-----------------  idx: 43  -----------------
Code:
static boolean setAccessibleWorkaround(final AccessibleObject o) {
    if (o == null || o.isAccessible()) {
      return false;
    }
    final Member m = (Member) o;
    if (!o.isAccessible()
        && Modifier.isPublic(m.getModifiers())
        && isPackageAccess(m.getDeclaringClass().getModifiers())) {
      try {
        o.setAccessible(true);
        return true;
      } catch (final SecurityException e) { // NOPMD
        // ignore in favor of subsequent IllegalAccessException
      }
    }
    return false;
  }
Summary 1: This method is a workaround for a limitation in Java's access control mechanism, where it is not possible to access private members of a class from a different package .
Summary 2: Attempts to make a non-accessible object accessible if it is public and in a package, returning a boolean indicating success or failure .
Summary 3: A workaround to set accessibility of a Java accessible object .
Summary 4: XXX Default access superclass workaround .
Summary 5: Sets the accessible flag on the specified accessible object, returning true if successful .

-----------------  idx: 44  -----------------
Code:
public LockEntry addLockEntry() {

        Element lockentry = addChild(root, "lockentry", childNames, false); //$NON-NLS-1$
        Element locktype = appendChild(lockentry, "locktype"); //$NON-NLS-1$
        appendChild(locktype, "write"); //$NON-NLS-1$

        LockEntry result = null;
        try {
            result = new LockEntry(lockentry);
        } catch (MalformedElementException e) {
            Assert.isTrue(false, Policy.bind("assert.internalError")); //$NON-NLS-1$
        }

        return result;
    }
Summary 1: Add a new lock entry to the current element .
Summary 2: Add a new lockentry element to the root element .
Summary 3: Adds a lock entry to the root element of the XML document and returns the created LockEntry object .
Summary 4: Creates a new lockentry and adds it to this supported lock . Returns an editor on the new lockentry .
Summary 5: Creates and returns a new LockEntry object with a write lock type .

-----------------  idx: 45  -----------------
Code:
public File getCommonDir(final File dir1, final File dir2) throws IOException {
		List<File> parts1 = getParentDirs(dir1);
		List<File> parts2 = getParentDirs(dir2);
		File matched = null;

		final int maxCommonSize = Math.min(parts1.size(), parts2.size());
		for (int i = 0; i < maxCommonSize; ++i) {
			if (parts1.get(i).equals(parts2.get(i))) {
				matched = parts1.get(i);
			} else {
				break;
			}
		}

		return matched;
	}
Summary 1: Find the common parent directory between two files .
Summary 2: Get the most common parent directory between two files .
Summary 3: Finds the common ancestor directory between two given directories .
Summary 4: Get the common directory between two input directories .
Summary 5: Gets the longest common parent directory path of two paths .

-----------------  idx: 46  -----------------
Code:
private static byte[] _toByteArray(InputStream stream) throws AlgoliaException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int read;
        byte[] buffer = new byte[1024];

        try {
            while ((read = stream.read(buffer, 0, buffer.length)) != -1) {
                out.write(buffer, 0, read);
            }

            out.flush();
            return out.toByteArray();
        } catch (IOException e) {
            throw new AlgoliaException("Error while reading stream: " + e.getMessage());
        }
    }
Summary 1: Converts an input stream to a byte array by reading and writing data into a ByteArrayOutputStream .
Summary 2: Converts an InputStream into a byte array, throwing an AlgoliaException on input/output errors .
Summary 3: Convert an input stream to a byte array .
Summary 4: Reads the InputStream into a byte array
Summary 5: Converts an InputStream into a byte array .

-----------------  idx: 47  -----------------
Code:
public Object execute(final Map<Object, Object> iArgs) {
    if (className == null) {
      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");
    }

    final ODatabaseDocument database = getDatabase();
    if (ifExists && !database.getMetadata().getSchema().existsClass(className)) {
      return true;
    }
    final OClass cls = database.getMetadata().getSchema().getClass(className);
    if (cls == null) {
      return null;
    }

    final long records = cls.count(true);

    if (records > 0 && !unsafe) {
      // NOT EMPTY, CHECK IF CLASS IS OF VERTEX OR EDGES
      if (cls.isSubClassOf("V")) {
        // FOUND VERTEX CLASS
        throw new OCommandExecutionException("'DROP CLASS' command cannot drop class '" + className
            + "' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it");
      } else if (cls.isSubClassOf("E")) {
        // FOUND EDGE CLASS
        throw new OCommandExecutionException("'DROP CLASS' command cannot drop class '" + className
            + "' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it");
      }
    }

    database.getMetadata().getSchema().dropClass(className);

    if (records > 0 && unsafe) {
      // NOT EMPTY, CHECK IF CLASS IS OF VERTEX OR EDGES
      if (cls.isSubClassOf("V")) {
        // FOUND VERTICES
        if (unsafe)
          OLogManager.instance().warn(this,
              "Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges", className,
              records);
      } else if (cls.isSubClassOf("E")) {
        // FOUND EDGES
        OLogManager.instance().warn(this,
            "Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices", className, records);
      }
    }

    return true;
  }
Summary 1: Drops a class from the database .
Summary 2: Execute the DROP CLASS .
Summary 3: Execute a command to drop a database class, with handling for different scenarios and options .
Summary 4: Executes the drop class command after validating safety conditions and ensuring the class exists .
Summary 5: This function executes the command by dropping the class from the database's schema .

-----------------  idx: 48  -----------------
Code:
public void setComponentCreateServiceFactory(final ComponentCreateServiceFactory componentCreateServiceFactory) {
        if (componentCreateServiceFactory == null) {
            throw EeLogger.ROOT_LOGGER.nullVar("componentCreateServiceFactory", "component", getComponentName());
        }
        this.componentCreateServiceFactory = componentCreateServiceFactory;
    }
Summary 1: Set the component create service factory, throwing an exception if the provided factory is null .
Summary 2: Set the component create service factory for this component .
Summary 3: Set the component create service factory .
Summary 4: Sets the factory for creating service components, throwing an exception if the provided factory is null .
Summary 5: Sets the factory used to create services for this component .

-----------------  idx: 49  -----------------
Code:
private void addPrivateCredential(final Subject subject, final Object credential) {
        if (!WildFlySecurityManager.isChecking()) {
            subject.getPrivateCredentials().add(credential);
        }
        else {
            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
                subject.getPrivateCredentials().add(credential);
                return null;
            });
        }
    }
Summary 1: Add a private credential to the subject .
Summary 2: Adds a private credential to a subject with handling for security manager checks .
Summary 3: Add a private credential to the subject, with the option to perform the operation with privileges .
Summary 4: Add a private credential to the subject .
Summary 5: Add the specified credential to the subject s private credentials set .

