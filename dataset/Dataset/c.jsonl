{"file_path": "/home/Downloads/project/c-project/linux/drivers/media/v4l2-core/v4l2-dev.c", "function": "static inline unsigned long *devnode_bits(enum vfl_devnode_type vfl_type)\n{\n\t/* Any types not assigned to fixed minor ranges must be mapped to\n\t   one single bitmap for the purposes of finding a free node number\n\t   since all those unassigned types use the same minor range. */\n\tint idx = (vfl_type > VFL_TYPE_RADIO) ? VFL_TYPE_MAX - 1 : vfl_type;\n\n\treturn devnode_nums[idx];\n}", "summary": "Return the bitmap corresponding to vfl_type"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Mayaqua/Kernel.c", "function": "THREAD *NewThreadInternal(THREAD_PROC *thread_proc, void *param)\n{\n\tTHREAD *t;\n\tUINT retry = 0;\n\t// Validate arguments\n\tif (thread_proc == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\t// Initialize Thread object\n\tt = ZeroMalloc(sizeof(THREAD));\n\tt->init_finished_event = NewEvent();\n\n\tt->param = param;\n\tt->ref = NewRef();\n\tt->thread_proc = thread_proc;\n\n\t// Wait until the OS to initialize the thread\n\twhile (true)\n\t{\n\t\tif ((retry++) > 60)\n\t\t{\n\t\t\tprintf(\"\\n\\n*** error: new thread create failed.\\n\\n\");\n\t\t\tAbortExit();\n\t\t}\n\t\tif (OSInitThread(t))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tSleepThread(500);\n\t}\n\n\t// KS\n\tKS_INC(KS_NEWTHREAD_COUNT);\n\n\treturn t;\n}", "summary": "Creating a thread"}
{"file_path": "/home/Downloads/project/homebrew/tarsnap/tar/chunks/chunks_write.c", "function": "chunks_write_ispresent(CHUNKS_W * C, const uint8_t * hash)\n{\n\n\tif (rwhashtab_read(C->HT, hash) != NULL)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}", "summary": "C hash If a chunk with hash hash exists return 0 otherwise return 1"}
{"file_path": "/home/Downloads/project/homebrew/suricata/src/detect-engine.c", "function": "static int DetectEngineTest09(void)\n{\n    const char *conf =\n        \"%YAML 1.1\\n\"\n        \"---\\n\"\n        \"detect-engine:\\n\"\n        \"  - profile: custom\\n\"\n        \"  - custom-values:\\n\"\n        \"      toclient-groups: BA\\n\"\n        \"      toserver-groups: BA\\n\"\n        \"  - inspection-recursion-limit: 10\\n\";\n\n    DetectEngineCtx *de_ctx = NULL;\n    int result = 0;\n\n    if (DetectEngineInitYamlConf(conf) == -1)\n        return 0;\n    de_ctx = DetectEngineCtxInit();\n    if (de_ctx == NULL)\n        goto end;\n\n    if (de_ctx->max_uniq_toclient_groups == 20 &&\n        de_ctx->max_uniq_toserver_groups == 40)\n        result = 1;\n\n end:\n    if (de_ctx != NULL)\n        DetectEngineCtxFree(de_ctx);\n\n    DetectEngineDeInitYamlConf();\n\n    return result;\n}", "summary": "test bug 892 bad values"}
{"file_path": "/home/Downloads/project/homebrew/librdkafka/src/rdkafka_topic.c", "function": "static void rd_kafka_topic_propagate_notexists (rd_kafka_itopic_t *rkt,\n                                                rd_kafka_resp_err_t err) {\n        shptr_rd_kafka_toppar_t *s_rktp;\n        int i;\n\n        if (rkt->rkt_rk->rk_type != RD_KAFKA_CONSUMER)\n                return;\n\n\n        /* Notify consumers that the topic doesn't exist. */\n        RD_LIST_FOREACH(s_rktp, &rkt->rkt_desp, i)\n                rd_kafka_toppar_enq_error(rd_kafka_toppar_s2i(s_rktp), err,\n                                          \"topic does not exist\");\n}", "summary": "Topic rkt does not exist propagate to interested parties"}
{"file_path": "/home/Downloads/project/homebrew/ettercap/src/ec_connbuf.c", "function": "void connbuf_wipe(struct conn_buf *cb)\n{\n   struct conn_pck_list *e;\n\n   DEBUG_MSG(\"connbuf_wipe\");\n   \n   CONNBUF_LOCK(cb->connbuf_mutex);\n   \n   /* delete the list */\n   while ((e = TAILQ_FIRST(&cb->connbuf_tail)) != TAILQ_END(&cb->connbuf_tail)) {\n      TAILQ_REMOVE(&cb->connbuf_tail, e, next);\n      SAFE_FREE(e->buf);\n      SAFE_FREE(e);\n   }\n\n   /* reset the buffer */\n   cb->size = 0;\n   TAILQ_INIT(&cb->connbuf_tail);\n   \n   CONNBUF_UNLOCK(cb->connbuf_mutex);\n}", "summary": "empty a give buffer"}
{"file_path": "/home/Downloads/project/homebrew/yasm/modules/preprocs/gas/gas-preproc.c", "function": "static int handle_if(yasm_preproc_gas *pp, int is_true)\n{\n    assert(pp->depth >= 0);\n    assert(pp->skip_depth == 0);\n    if (is_true) {\n        pp->depth++;\n    } else {\n        pp->skip_depth = 1;\n    }\n    return 1;\n}", "summary": "If directive helpers"}
{"file_path": "/home/Downloads/project/homebrew/tcpkali/deps/libev/ev.c", "function": "fd_event (EV_P_ int fd, int revents)\n{\n  ANFD *anfd = anfds + fd;\n\n  if (expect_true (!anfd->reify))\n    fd_event_nocheck (EV_A_ fd, revents);\n}", "summary": "because that means they changed while we were polling for new events"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Cedar/Server.c", "function": "bool SiCallReadLogFile(SERVER *s, FARM_MEMBER *f, RPC_READ_LOG_FILE *t)\n{\n\tPACK *p;\n\t// Validate arguments\n\tif (s == NULL || f == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tp = NewPack();\n\tOutRpcReadLogFile(p, t);\n\tFreeRpcReadLogFile(t);\n\tZero(t, sizeof(RPC_READ_LOG_FILE));\n\n\tp = SiCallTask(f, p, \"readlogfile\");\n\n\tif (p == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tInRpcReadLogFile(t, p);\n\tFreePack(p);\n\n\treturn true;\n}", "summary": "Log file reading directive"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/arm/mach-zynq/pm.c", "function": "void __init zynq_pm_late_init(void)\n{\n\tu32 reg;\n\n\tddrc_base = zynq_pm_ioremap(\"xlnx,zynq-ddrc-a05\");\n\tif (!ddrc_base) {\n\t\tpr_warn(\"%s: Unable to map DDRC IO memory.\\n\", __func__);\n\t} else {\n\t\t/*\n\t\t * Enable DDRC clock stop feature. The HW takes care of\n\t\t * entering/exiting the correct mode depending\n\t\t * on activity state.\n\t\t */\n\t\treg = readl(ddrc_base + DDRC_DRAM_PARAM_REG3_OFFS);\n\t\treg |= DDRC_CLOCKSTOP_MASK;\n\t\twritel(reg, ddrc_base + DDRC_DRAM_PARAM_REG3_OFFS);\n\t}\n}", "summary": "Power management init Initialization of power management related features and infrastructure"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/gpio/gpiolib.c", "function": "void gpiod_add_lookup_table(struct gpiod_lookup_table *table)\n{\n\tmutex_lock(&gpio_lookup_lock);\n\n\tlist_add_tail(&table->list, &gpio_lookup_list);\n\n\tmutex_unlock(&gpio_lookup_lock);\n}", "summary": "register GPIO device consumers"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/fddi/skfp/skfddi.c", "function": "static int skfp_close(struct net_device *dev)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *bp = &smc->os;\n\n\tCLI_FBI();\n\tsmt_reset_defaults(smc, 1);\n\tcard_stop(smc);\n\tmac_drv_clear_tx_queue(smc);\n\tmac_drv_clear_rx_queue(smc);\n\n\tnetif_stop_queue(dev);\n\t/* Deregister (free) IRQ */\n\tfree_irq(dev->irq, dev);\n\n\tskb_queue_purge(&bp->SendSkbQueue);\n\tbp->QueueSkb = MAX_TX_QUEUE_LEN;\n\n\treturn 0;\n}\t\t\t\t// skfp_close", "summary": "This routine closes the adapter and brings it to a safe state"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/x86/kernel/reboot.c", "function": "void run_crash_ipi_callback(struct pt_regs *regs)\n{\n\tif (crash_ipi_issued)\n\t\tcrash_nmi_callback(0, regs);\n}", "summary": "Check if the crash dumping IPI got issued and if so call its callback directly"}
{"file_path": "/home/Downloads/project/c-project/linux/fs/jfs/jfs_mount.c", "function": "static int logMOUNT(struct super_block *sb)\n{\n\tstruct jfs_log *log = JFS_SBI(sb)->log;\n\tstruct lrd lrd;\n\n\tlrd.logtid = 0;\n\tlrd.backchain = 0;\n\tlrd.type = cpu_to_le16(LOG_MOUNT);\n\tlrd.length = 0;\n\tlrd.aggregate = cpu_to_le32(new_encode_dev(sb->s_bdev->bd_dev));\n\tlmLog(log, NULL, &lrd, NULL);\n\n\treturn 0;\n}", "summary": "function write a MOUNT log record for file system"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/x86/kernel/fpu/core.c", "function": "static inline void copy_init_fpstate_to_fpregs(void)\n{\n\tfpregs_lock();\n\n\tif (use_xsave())\n\t\tcopy_kernel_to_xregs(&init_fpstate.xsave, -1);\n\telse if (static_cpu_has(X86_FEATURE_FXSR))\n\t\tcopy_kernel_to_fxregs(&init_fpstate.fxsave);\n\telse\n\t\tcopy_kernel_to_fregs(&init_fpstate.fsave);\n\n\tif (boot_cpu_has(X86_FEATURE_OSPKE))\n\t\tcopy_init_pkru_to_fpregs();\n\n\tfpregs_mark_activate();\n\tfpregs_unlock();\n}", "summary": "Clear FPU registers by setting them up from the init fpstate"}
{"file_path": "/home/Downloads/project/homebrew/xaric/signals.c", "function": "static RETSIGTYPE sig_child(int sig)\n{\n    got_sigchild++;\n\n    OLD_HANDLER(old_sigchild, sig);\n}", "summary": "so we can reap our dead children"}
{"file_path": "/home/Downloads/project/c-project/linux/net/wimax/op-msg.c", "function": "int wimax_msg(struct wimax_dev *wimax_dev, const char *pipe_name,\n\t      const void *buf, size_t size, gfp_t gfp_flags)\n{\n\tint result = -ENOMEM;\n\tstruct sk_buff *skb;\n\n\tskb = wimax_msg_alloc(wimax_dev, pipe_name, buf, size, gfp_flags);\n\tif (IS_ERR(skb))\n\t\tresult = PTR_ERR(skb);\n\telse\n\t\tresult = wimax_msg_send(wimax_dev, skb);\n\treturn result;\n}", "summary": "Sends a free form message to user space on the device"}
{"file_path": "/home/Downloads/project/c-project/linux/mm/swapfile.c", "function": "sector_t map_swap_page(struct page *page, struct block_device **bdev)\n{\n\tswp_entry_t entry;\n\tentry.val = page_private(page);\n\treturn map_swap_entry(entry, bdev);\n}", "summary": "Returns the page offset into bdev for the specified page s swap entry"}
{"file_path": "/home/Downloads/project/c-project/linux/kernel/irq/chip.c", "function": "void irq_chip_eoi_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_eoi(data);\n}", "summary": "Invoke EOI on the parent interrupt"}
{"file_path": "/home/Downloads/project/c-project/postgres/src/backend/access/common/indextuple.c", "function": "CopyIndexTuple(IndexTuple source)\n{\n\tIndexTuple\tresult;\n\tSize\t\tsize;\n\n\tsize = IndexTupleSize(source);\n\tresult = (IndexTuple) palloc(size);\n\tmemcpy(result, source, size);\n\treturn result;\n}", "summary": "Create a palloc d copy of an index tuple"}
{"file_path": "/home/Downloads/project/c-project/qemu/cpus.c", "function": "int64_t cpu_get_icount(void)\n{\n    int64_t icount;\n    unsigned start;\n\n    do {\n        start = seqlock_read_begin(&timers_state.vm_clock_seqlock);\n        icount = cpu_get_icount_locked();\n    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, start));\n\n    return icount;\n}", "summary": "Return the virtual CPU time based on the instruction counter"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Mayaqua/Network.c", "function": "bool StrToMask6(IP *mask, char *str)\n{\n\t// Validate arguments\n\tif (mask == NULL || str == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\tif (str[0] == '/')\n\t{\n\t\tstr++;\n\t}\n\n\tif (IsNum(str))\n\t{\n\t\tUINT n = ToInt(str);\n\n\t\tif (n <= 128)\n\t\t{\n\t\t\tIntToSubnetMask6(mask, n);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (StrToIP(mask, str) == false)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn IsIP6(mask);\n\t\t}\n\t}\n}", "summary": "Convert the string to an IPv6 mask"}
{"file_path": "/home/Downloads/project/homebrew/ettercap/src/ec_error.c", "function": "void warn_msg(char *file, const char *function, int line, char *message, ...)\n{\n\n   va_list ap;\n   char warnmsg[ERROR_MSG_LEN + 1];\n\n\n   va_start(ap, message);\n   vsnprintf(warnmsg, ERROR_MSG_LEN, message, ap);\n   va_end(ap);\n\n   DEBUG_MSG(\"WARNING: [%s:%s:%d] %s \\n\", file, function, line, warnmsg);\n\n   fprintf(stdout, \"WARNING: [%s:%s:%d]\\n\\n %s \\n\\n\", file, function, line, warnmsg);\n\n}", "summary": "print a warning message no exit"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/ata/pata_via.c", "function": "static int via_reinit_one(struct pci_dev *pdev)\n{\n\tstruct ata_host *host = pci_get_drvdata(pdev);\n\tint rc;\n\n\trc = ata_pci_device_do_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tvia_fixup(pdev, host->private_data);\n\n\tata_host_resume(host);\n\treturn 0;\n}", "summary": "reinit after resume"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/i2c/busses/i2c-ibm_iic.c", "function": "static inline u8 iic_clckdiv(unsigned int opb)\n{\n\t/* Compatibility kludge, should go away after all cards\n\t * are fixed to fill correct value for opbfreq.\n\t * Previous driver version used hardcoded divider value 4,\n\t * it corresponds to OPB frequency from the range (40, 50] MHz\n\t */\n\tif (!opb){\n\t\tprintk(KERN_WARNING \"ibm-iic: using compatibility value for OPB freq,\"\n\t\t\t\" fix your board specific setup\\n\");\n\t\topb = 50000000;\n\t}\n\n\t/* Convert to MHz */\n\topb /= 1000000;\n\n\tif (opb < 20 || opb > 150){\n\t\tprintk(KERN_WARNING \"ibm-iic: invalid OPB clock frequency %u MHz\\n\",\n\t\t\topb);\n\t\topb = opb < 20 ? 20 : 150;\n\t}\n\treturn (u8)((opb + 9) / 10 - 1);\n}", "summary": "Calculates IICx_CLCKDIV value for a specific OPB clock frequency"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/parport/parport_ip32.c", "function": "static inline void parport_ip32_write_econtrol(struct parport *p,\n\t\t\t\t\t       unsigned int c)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\twriteb(c, priv->regs.ecr);\n}", "summary": "write new contents to the ECR register"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/chelsio/cxgb3/t3_hw.c", "function": "static inline unsigned int pm_num_pages(unsigned int mem_size,\n\t\t\t\t\tunsigned int pg_size)\n{\n\tunsigned int n = mem_size / pg_size;\n\n\treturn n - n % 24;\n}", "summary": "calculate the number of pages of the payload memory"}
{"file_path": "/home/Downloads/project/homebrew/julius/msvc/Library_PortAudio/src/pablio/pablio.c", "function": "long WriteAudioStream( PABLIO_Stream *aStream, void *data, long numFrames )\n{\n    long bytesWritten;\n    char *p = (char *) data;\n    long numBytes = aStream->bytesPerFrame * numFrames;\n    while( numBytes > 0)\n    {\n        bytesWritten = PaUtil_WriteRingBuffer( &aStream->outFIFO, p, numBytes );\n        numBytes -= bytesWritten;\n        p += bytesWritten;\n        if( numBytes > 0) Pa_Sleep(10);\n    }\n    return numFrames;\n}", "summary": "Write data to ring buffer"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/can/usb/peak_usb/pcan_usb.c", "function": "static int pcan_usb_probe(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *if_desc;\n\tint i;\n\n\tif_desc = intf->altsetting;\n\n\t/* check interface endpoint addresses */\n\tfor (i = 0; i < if_desc->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *ep = &if_desc->endpoint[i].desc;\n\n\t\tswitch (ep->bEndpointAddress) {\n\t\tcase PCAN_USB_EP_CMDOUT:\n\t\tcase PCAN_USB_EP_CMDIN:\n\t\tcase PCAN_USB_EP_MSGOUT:\n\t\tcase PCAN_USB_EP_MSGIN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}", "summary": "probe function for new PCAN USB usb interface"}
{"file_path": "/home/Downloads/project/platform/qpc/3rd_party/nucleo-h743zi/Drivers/BSP/Components/mfxstm32l152/mfxstm32l152.c", "function": "uint8_t mfxstm32l152_IDD_GetITStatus(uint16_t DeviceAddr)\n{\n  /* Return IDD interrupt status */\n  return(mfxstm32l152_GlobalITStatus(DeviceAddr, MFXSTM32L152_IRQ_IDD));\n}", "summary": "get Idd interrupt status"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/arc/kernel/devtree.c", "function": "const struct machine_desc * __init setup_machine_fdt(void *dt)\n{\n\tconst struct machine_desc *mdesc;\n\tunsigned long dt_root;\n\n\tif (!early_init_dt_scan(dt))\n\t\treturn NULL;\n\n\tmdesc = of_flat_dt_match_machine(NULL, arch_get_next_mach);\n\tif (!mdesc)\n\t\tmachine_halt();\n\n\tdt_root = of_get_flat_dt_root();\n\tarc_set_early_base_baud(dt_root);\n\n\treturn mdesc;\n}", "summary": "Machine setup when an dtb was passed to the kernel"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/base/node.c", "function": "void unregister_memory_block_under_nodes(struct memory_block *mem_blk)\n{\n\tif (mem_blk->nid == NUMA_NO_NODE)\n\t\treturn;\n\n\tsysfs_remove_link(&node_devices[mem_blk->nid]->dev.kobj,\n\t\t\t  kobject_name(&mem_blk->dev.kobj));\n\tsysfs_remove_link(&mem_blk->dev.kobj,\n\t\t\t  kobject_name(&node_devices[mem_blk->nid]->dev.kobj));\n}", "summary": "Unregister a memory block device under the node it spans"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/perf/arm_pmu.c", "function": "const char *perf_pmu_name(void)\n{\n\tif (!__oprofile_cpu_pmu)\n\t\treturn NULL;\n\n\treturn __oprofile_cpu_pmu->name;\n}", "summary": "Despite the names these two functions are CPU specific and are used by the OProfile perf code"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/pci/bus.c", "function": "void pci_bus_add_devices(const struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Skip already-added devices */\n\t\tif (pci_dev_is_added(dev))\n\t\t\tcontinue;\n\t\tpci_bus_add_device(dev);\n\t}\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t/* Skip if device attach failed */\n\t\tif (!pci_dev_is_added(dev))\n\t\t\tcontinue;\n\t\tchild = dev->subordinate;\n\t\tif (child)\n\t\t\tpci_bus_add_devices(child);\n\t}\n}", "summary": "start driver for PCI devices"}
{"file_path": "/home/Downloads/project/c-project/macvim/src/os_msdos.c", "function": "mch_nodetype(char_u *name)\n{\n    if (STRICMP(name, \"AUX\") == 0\n\t    || STRICMP(name, \"CON\") == 0\n\t    || STRICMP(name, \"CLOCK$\") == 0\n\t    || STRICMP(name, \"NUL\") == 0\n\t    || STRICMP(name, \"PRN\") == 0\n\t    || ((STRNICMP(name, \"COM\", 3) == 0\n\t\t    || STRNICMP(name, \"LPT\", 3) == 0)\n\t\t&& VIM_ISDIGIT(name[3])\n\t\t&& name[4] == NUL))\n\treturn NODE_WRITABLE;\n    /* TODO: NODE_OTHER? */\n    return NODE_NORMAL;\n}", "summary": "Check what name is NODE_NORMAL file or directory or does n t exist NODE_WRITABLE writable device socket fifo etc"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/input/misc/max8925_onkey.c", "function": "static irqreturn_t max8925_onkey_handler(int irq, void *data)\n{\n\tstruct max8925_onkey_info *info = data;\n\tint state;\n\n\tstate = max8925_reg_read(info->i2c, MAX8925_ON_OFF_STATUS);\n\n\tinput_report_key(info->idev, KEY_POWER, state & SW_INPUT);\n\tinput_sync(info->idev);\n\n\tdev_dbg(info->dev, \"onkey state:%d\\n\", state);\n\n\t/* Enable hardreset to halt if system isn't shutdown on time */\n\tmax8925_set_bits(info->i2c, MAX8925_SYSENSEL,\n\t\t\t HARDRESET_EN, HARDRESET_EN);\n\n\treturn IRQ_HANDLED;\n}", "summary": "MAX8925 gives us an interrupt when ONKEY is pressed or released"}
{"file_path": "/home/Downloads/project/c-project/linux/net/sunrpc/xprtsock.c", "function": "static void xs_udp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\tseq_printf(seq, \"\\txprt:\\tudp %u %lu %lu %lu %lu %llu %llu \"\n\t\t\t\"%lu %llu %llu\\n\",\n\t\t\ttransport->srcport,\n\t\t\txprt->stat.bind_count,\n\t\t\txprt->stat.sends,\n\t\t\txprt->stat.recvs,\n\t\t\txprt->stat.bad_xids,\n\t\t\txprt->stat.req_u,\n\t\t\txprt->stat.bklog_u,\n\t\t\txprt->stat.max_slots,\n\t\t\txprt->stat.sending_u,\n\t\t\txprt->stat.pending_u);\n}", "summary": "display UDP socket specifc stats"}
{"file_path": "/home/Downloads/project/platform/qpc/3rd_party/nucleo-h743zi/Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_mdios.c", "function": "HAL_StatusTypeDef HAL_MDIOS_EnableEvents(MDIOS_HandleTypeDef *hmdios)\n{\n  /* Process Locked */\n  __HAL_LOCK(hmdios);\n\n  /* Enable MDIOS interrupts: Register Write, Register Read and Error ITs */\n  __HAL_MDIOS_ENABLE_IT(hmdios, (MDIOS_IT_WRITE | MDIOS_IT_READ | MDIOS_IT_ERROR));\n\n  /* Process Unlocked */\n  __HAL_UNLOCK(hmdios);\n\n  return HAL_OK;\n}", "summary": "Enables Events for MDIOS peripheral"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/powerpc/oprofile/op_model_cell.c", "function": "static int cell_sync_start(void)\n{\n\tif ((profiling_mode == SPU_PROFILING_CYCLES) ||\n\t    (profiling_mode == SPU_PROFILING_EVENTS))\n\t\treturn spu_sync_start();\n\telse\n\t\treturn DO_GENERIC_SYNC;\n}", "summary": "This function is called from the generic OProfile driver"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c", "function": "static int lio_get_regs_len(struct net_device *dev)\n{\n\tstruct lio *lio = GET_LIO(dev);\n\tstruct octeon_device *oct = lio->oct_dev;\n\n\tswitch (oct->chip_id) {\n\tcase OCTEON_CN23XX_PF_VID:\n\t\treturn OCT_ETHTOOL_REGDUMP_LEN_23XX;\n\tcase OCTEON_CN23XX_VF_VID:\n\t\treturn OCT_ETHTOOL_REGDUMP_LEN_23XX_VF;\n\tdefault:\n\t\treturn OCT_ETHTOOL_REGDUMP_LEN;\n\t}\n}", "summary": "Return register dump len"}
{"file_path": "/home/Downloads/project/c-project/qemu/target/arm/translate.c", "function": "static TCGv_i64 gen_mulu_i64_i32(TCGv_i32 a, TCGv_i32 b)\n{\n    TCGv_i32 lo = tcg_temp_new_i32();\n    TCGv_i32 hi = tcg_temp_new_i32();\n    TCGv_i64 ret;\n\n    tcg_gen_mulu2_i32(lo, hi, a, b);\n    tcg_temp_free_i32(a);\n    tcg_temp_free_i32(b);\n\n    ret = tcg_temp_new_i64();\n    tcg_gen_concat_i32_i64(ret, lo, hi);\n    tcg_temp_free_i32(lo);\n    tcg_temp_free_i32(hi);\n\n    return ret;\n}", "summary": "32x32 64 multiply"}
{"file_path": "/home/Downloads/project/c-project/linux/net/netfilter/ipvs/ip_vs_ctl.c", "function": "struct ip_vs_dest *ip_vs_find_tunnel(struct netns_ipvs *ipvs, int af,\n\t\t\t\t     const union nf_inet_addr *daddr,\n\t\t\t\t     __be16 tun_port)\n{\n\tstruct ip_vs_dest *dest;\n\tunsigned int hash;\n\n\t/* Check for \"full\" addressed entries */\n\thash = ip_vs_rs_hashkey(af, daddr, tun_port);\n\n\thlist_for_each_entry_rcu(dest, &ipvs->rs_table[hash], d_list) {\n\t\tif (dest->tun_port == tun_port &&\n\t\t    dest->af == af &&\n\t\t    ip_vs_addr_equal(af, &dest->addr, daddr) &&\n\t\t    IP_VS_DFWD_METHOD(dest) == IP_VS_CONN_F_TUNNEL) {\n\t\t\t/* HIT */\n\t\t\treturn dest;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "summary": "Find real service record by af addr tun_port"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Cedar/Wpc.c", "function": "WPC_ENTRY *WpcFindDataEntry(LIST *o, char *name)\n{\n\tUINT i;\n\tchar name_str[WPC_DATA_ENTRY_SIZE];\n\t// Validate arguments\n\tif (o == NULL || name == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tWpcFillEntryName(name_str, name);\n\n\tfor (i = 0;i < LIST_NUM(o);i++)\n\t{\n\t\tWPC_ENTRY *e = LIST_DATA(o, i);\n\n\t\tif (Cmp(e->EntryName, name_str, WPC_DATA_ENTRY_SIZE) == 0)\n\t\t{\n\t\t\treturn e;\n\t\t}\n\t}\n\n\treturn NULL;\n}", "summary": "Search for the data entry"}
{"file_path": "/home/Downloads/project/c-project/linux/sound/core/seq/seq_virmidi.c", "function": "static int snd_virmidi_dev_register(struct snd_rawmidi *rmidi)\n{\n\tstruct snd_virmidi_dev *rdev = rmidi->private_data;\n\tint err;\n\n\tswitch (rdev->seq_mode) {\n\tcase SNDRV_VIRMIDI_SEQ_DISPATCH:\n\t\terr = snd_virmidi_dev_attach_seq(rdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SNDRV_VIRMIDI_SEQ_ATTACH:\n\t\tif (rdev->client == 0)\n\t\t\treturn -EINVAL;\n\t\t/* should check presence of port more strictly.. */\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"ALSA: seq_virmidi: seq_mode is not set: %d\\n\", rdev->seq_mode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "summary": "register the device"}
{"file_path": "/home/Downloads/project/c-project/darwin-xnu/bsd/nfs/nfs_vnops.c", "function": "nfs_dir_buf_freespace(struct nfsbuf *bp, int rdirplus)\n{\n\tstruct nfs_dir_buf_header *ndbhp = (struct nfs_dir_buf_header*)bp->nb_data;\n\tuint32_t space;\n\n\tif (!ndbhp)\n\t\treturn (0);\n\tspace = bp->nb_bufsize - ndbhp->ndbh_entry_end;\n\tif (rdirplus)\n\t\tspace -= ndbhp->ndbh_count * sizeof(struct nfs_vattr);\n\treturn (space);\n}", "summary": "calculate how much space is available for additional directory entries"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/tty/serial/ar933x_uart.c", "function": "static unsigned long ar933x_uart_get_baud(unsigned int clk,\n\t\t\t\t\t  unsigned int scale,\n\t\t\t\t\t  unsigned int step)\n{\n\tu64 t;\n\tu32 div;\n\n\tdiv = (2 << 16) * (scale + 1);\n\tt = clk;\n\tt *= step;\n\tt += (div / 2);\n\tdo_div(t, div);\n\n\treturn t;\n}", "summary": "baudrate clk scale 1 step 1 2 17"}
{"file_path": "/home/Downloads/project/homebrew/strongswan/src/libtnccs/plugins/tnccs_20/tnccs_20_server.c", "function": "static void build_retry_batch(private_tnccs_20_server_t *this)\n{\n\tif (this->batch_type == PB_BATCH_SRETRY)\n\t{\n\t\t/* retry batch has already been selected */\n\t\treturn;\n\t}\n\tchange_batch_type(this, PB_BATCH_SRETRY);\n}", "summary": "Build an SRETRY batch"}
{"file_path": "/home/Downloads/project/homebrew/mc/src/vfs/smbfs/helpers/lib/util.c", "function": "file_exist (char *fname, SMB_STRUCT_STAT * sbuf)\n{\n    SMB_STRUCT_STAT st;\n    if (!sbuf)\n        sbuf = &st;\n\n    if (sys_stat (fname, sbuf) != 0)\n        return (False);\n\n    return (S_ISREG (sbuf->st_mode));\n}", "summary": "check if a file exists"}
{"file_path": "/home/Downloads/project/homebrew/suricata/src/source-netmap.c", "function": "static void NetmapReleasePacket(Packet *p)\n{\n    NetmapThreadVars *ntv = (NetmapThreadVars *)p->netmap_v.ntv;\n\n    if ((ntv->copy_mode != NETMAP_COPY_MODE_NONE) && !PKT_IS_PSEUDOPKT(p)) {\n        NetmapWritePacket(ntv, p);\n    }\n\n    PacketFreeOrRelease(p);\n}", "summary": "brief Packet release routine"}
{"file_path": "/home/Downloads/project/c-project/torch7/lib/TH/THHalf.c", "function": "THHalf TH_float2half(float f)\n{\n  THHalf h;\n  TH_float2halfbits(&f, &h.x);\n  return h;\n}", "summary": "Copyright 1993 2014 NVIDIA Corporation"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/wireless/marvell/libertas/main.c", "function": "static int lbs_dev_open(struct net_device *dev)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\tint ret = 0;\n\n\tif (!priv->iface_running) {\n\t\tret = lbs_start_iface(priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&priv->driver_lock);\n\n\tnetif_carrier_off(dev);\n\n\tif (!priv->tx_pending_len)\n\t\tnetif_wake_queue(dev);\n\n\tspin_unlock_irq(&priv->driver_lock);\n\nout:\n\treturn ret;\n}", "summary": "open the ethX interface"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/gpu/drm/tegra/dc.c", "function": "int tegra_dc_state_setup_clock(struct tegra_dc *dc,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct clk *clk, unsigned long pclk,\n\t\t\t       unsigned int div)\n{\n\tstruct tegra_dc_state *state = to_dc_state(crtc_state);\n\n\tif (!clk_has_parent(dc->clk, clk))\n\t\treturn -EINVAL;\n\n\tstate->clk = clk;\n\tstate->pclk = pclk;\n\tstate->div = div;\n\n\treturn 0;\n}", "summary": "check clock settings and store them in atomic state"}
{"file_path": "/home/Downloads/project/homebrew/Montage/lib/src/freetype-2.4.4/src/autofit/afhints.c", "function": "af_direction_compute( FT_Pos  dx,\n                        FT_Pos  dy )\n  {\n    FT_Pos        ll, ss;  /* long and short arm lengths */\n    AF_Direction  dir;     /* candidate direction        */\n\n\n    if ( dy >= dx )\n    {\n      if ( dy >= -dx )\n      {\n        dir = AF_DIR_UP;\n        ll  = dy;\n        ss  = dx;\n      }\n      else\n      {\n        dir = AF_DIR_LEFT;\n        ll  = -dx;\n        ss  = dy;\n      }\n    }\n    else /* dy < dx */\n    {\n      if ( dy >= -dx )\n      {\n        dir = AF_DIR_RIGHT;\n        ll  = dx;\n        ss  = dy;\n      }\n      else\n      {\n        dir = AF_DIR_DOWN;\n        ll  = dy;\n        ss  = dx;\n      }\n    }\n\n    ss *= 14;\n    if ( FT_ABS( ll ) <= FT_ABS( ss ) )\n      dir = AF_DIR_NONE;\n\n    return dir;\n  }", "summary": "compute the direction value of a given vector"}
{"file_path": "/home/Downloads/project/c-project/mpv/video/img_format.c", "function": "int mp_imgfmt_select_best_list(int *dst, int num_dst, int src)\n{\n    int best = 0;\n    for (int n = 0; n < num_dst; n++)\n        best = best ? mp_imgfmt_select_best(best, dst[n], src) : dst[n];\n    return best;\n}", "summary": "Same as mp_imgfmt_select_best but with a list of dst formats"}
{"file_path": "/home/Downloads/project/homebrew/julius/libsent/src/hmminfo/guess_cdHMM.c", "function": "guess_if_cd_hmm(HTK_HMM_INFO *hmminfo)\n{\n  HMM_Logical *dt;\n  int rnum, lnum, totalnum;\n\n  /* check if there is a logical HMM whose name includes either HMM_RC_DLIM\n     or HMM_LC_DLIM */\n  rnum = lnum = totalnum = 0;\n  for (dt = hmminfo->lgstart; dt; dt = dt->next) {\n    if (strstr(dt->name, HMM_RC_DLIM) != NULL) rnum++;\n    if (strstr(dt->name, HMM_LC_DLIM) != NULL) lnum++;\n    totalnum++;\n  }\n  if (rnum > 0) {\n    if (lnum == 0) {\n      jlog(\"Warning: guess_cdHMM: cannot handle right-context dependency correctly\\n\");\n      return(FALSE);\n    } else {\n      return(TRUE);\n    }\n  }\n  return(FALSE);\n}", "summary": "Guess whether the given HMM definition contains context dependent modeling just by the naming rule"}
{"file_path": "/home/Downloads/project/homebrew/mxml/mxml-file.c", "function": "mxml_fd_read(_mxml_fdbuf_t *buf)\t\t/* I - File descriptor buffer */\n{\n  int\tbytes;\t\t\t\t/* Bytes read... */\n\n\n /*\n  * Range check input...\n  */\n\n  if (!buf)\n    return (-1);\n\n /*\n  * Read from the file descriptor...\n  */\n\n  while ((bytes = (int)read(buf->fd, buf->buffer, sizeof(buf->buffer))) < 0)\n#ifdef EINTR\n    if (errno != EAGAIN && errno != EINTR)\n#else\n    if (errno != EAGAIN)\n#endif /* EINTR */\n      return (-1);\n\n  if (bytes == 0)\n    return (-1);\n\n /*\n  * Update the pointers and return success...\n  */\n\n  buf->current = buf->buffer;\n  buf->end     = buf->buffer + bytes;\n\n  return (0);\n}", "summary": "O 0 on success 1 on error"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/marvell/sky2.c", "function": "static void sky2_phy_reinit(struct sky2_port *sky2)\n{\n\tspin_lock_bh(&sky2->phy_lock);\n\tsky2_phy_init(sky2->hw, sky2->port);\n\tsky2_enable_rx_tx(sky2);\n\tspin_unlock_bh(&sky2->phy_lock);\n}", "summary": "Force a renegotiation"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/mtd/spi-nor/spi-nor.c", "function": "static void spi_nor_init_params(struct spi_nor *nor)\n{\n\tspi_nor_info_init_params(nor);\n\n\tspi_nor_manufacturer_init_params(nor);\n\n\tif ((nor->info->flags & (SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)) &&\n\t    !(nor->info->flags & SPI_NOR_SKIP_SFDP))\n\t\tspi_nor_sfdp_init_params(nor);\n\n\tspi_nor_post_sfdp_fixups(nor);\n\n\tspi_nor_late_init_params(nor);\n}", "summary": "Initialize the flash s parameters and settings"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Mayaqua/Str.c", "function": "bool IsSplitChar(char c, char *split_str)\n{\n\tUINT i, len;\n\tchar c_upper = ToUpper(c);\n\tif (split_str == NULL)\n\t{\n\t\tsplit_str = default_spliter;\n\t}\n\n\tlen = StrLen(split_str);\n\n\tfor (i = 0;i < len;i++)\n\t{\n\t\tif (ToUpper(split_str[i]) == c_upper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "summary": "Check whether the specified character is a delimiter"}
{"file_path": "/home/Downloads/project/c-project/linux/kernel/relay.c", "function": "static __poll_t relay_file_poll(struct file *filp, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct rchan_buf *buf = filp->private_data;\n\n\tif (buf->finalized)\n\t\treturn EPOLLERR;\n\n\tif (filp->f_mode & FMODE_READ) {\n\t\tpoll_wait(filp, &buf->read_wait, wait);\n\t\tif (!relay_buf_empty(buf))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn mask;\n}", "summary": "poll file op for relay files"}
{"file_path": "/home/Downloads/project/c-project/anypixel/firmware/controller/ThirdParty/lwip-1.4.1/src/core/pbuf.c", "function": "pbuf_free_ooseq_callback(void *arg)\n{\n  LWIP_UNUSED_ARG(arg);\n  pbuf_free_ooseq();\n}", "summary": "Just a callback function for tcpip_timeout that calls pbuf_free_ooseq"}
{"file_path": "/home/Downloads/project/c-project/linux/net/ceph/pagelist.c", "function": "void ceph_pagelist_set_cursor(struct ceph_pagelist *pl,\n\t\t\t      struct ceph_pagelist_cursor *c)\n{\n\tc->pl = pl;\n\tc->page_lru = pl->head.prev;\n\tc->room = pl->room;\n}", "summary": "Create a truncation point"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c", "function": "static int pch_gbe_mdio_read(struct net_device *netdev, int addr, int reg)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_hw *hw = &adapter->hw;\n\n\treturn pch_gbe_mac_ctrl_miim(hw, addr, PCH_GBE_HAL_MIIM_READ, reg,\n\t\t\t\t     (u16) 0);\n}", "summary": "The read function for mii"}
{"file_path": "/home/Downloads/project/c-project/micropython/ports/stm32/lcd.c", "function": "STATIC mp_obj_t pyb_lcd_command(mp_obj_t self_in, mp_obj_t instr_data_in, mp_obj_t val) {\n    pyb_lcd_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    // get whether instr or data\n    int instr_data = mp_obj_get_int(instr_data_in);\n\n    // get the buffer to send from\n    mp_buffer_info_t bufinfo;\n    uint8_t data[1];\n    pyb_buf_get_for_send(val, &bufinfo, data);\n\n    // send the data\n    for (uint i = 0; i < bufinfo.len; i++) {\n        lcd_out(self, instr_data, ((byte*)bufinfo.buf)[i]);\n    }\n\n    return mp_const_none;\n}", "summary": "instructions data to send"}
{"file_path": "/home/Downloads/project/homebrew/lci/lexer.c", "function": "LexemeList *createLexemeList(void)\n{\n\tLexemeList *p = malloc(sizeof(LexemeList));\n\tif (!p) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tp->num = 0;\n\tp->lexemes = NULL;\n\treturn p;\n}", "summary": "Creates a list of lexemes"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/fpga/fpga-bridge.c", "function": "void fpga_bridge_put(struct fpga_bridge *bridge)\n{\n\tdev_dbg(&bridge->dev, \"put\\n\");\n\n\tbridge->info = NULL;\n\tmodule_put(bridge->dev.parent->driver->owner);\n\tmutex_unlock(&bridge->mutex);\n\tput_device(&bridge->dev);\n}", "summary": "release a reference to a bridge"}
{"file_path": "/home/Downloads/project/c-project/linux/sound/pci/trident/trident_main.c", "function": "static int snd_trident_sis_init(struct snd_trident *trident)\n{\n\tint err;\n\n\tif ((err = snd_trident_sis_reset(trident)) < 0)\n\t\treturn err;\n\n\tsnd_trident_stop_all_voices(trident);\n\n\t/* initialize S/PDIF */\n\toutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\n\n\treturn 0;\n}", "summary": "initialize sis7018 chip"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/gpu/drm/radeon/radeon_device.c", "function": "void radeon_wb_fini(struct radeon_device *rdev)\n{\n\tradeon_wb_disable(rdev);\n\tif (rdev->wb.wb_obj) {\n\t\tif (!radeon_bo_reserve(rdev->wb.wb_obj, false)) {\n\t\t\tradeon_bo_kunmap(rdev->wb.wb_obj);\n\t\t\tradeon_bo_unpin(rdev->wb.wb_obj);\n\t\t\tradeon_bo_unreserve(rdev->wb.wb_obj);\n\t\t}\n\t\tradeon_bo_unref(&rdev->wb.wb_obj);\n\t\trdev->wb.wb = NULL;\n\t\trdev->wb.wb_obj = NULL;\n\t}\n}", "summary": "Disable Writeback and free memory"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/x86/pci/irq.c", "function": "static int pirq_serverworks_get(struct pci_dev *router, struct pci_dev *dev, int pirq)\n{\n\toutb(pirq, 0xc00);\n\treturn inb(0xc01) & 0xf;\n}", "summary": "ServerWorks PCI interrupts mapped to system IRQ lines through Index and Redirect I O registers 0x0c00 and 0x0c01"}
{"file_path": "/home/Downloads/project/platform/arduino/src/src/lv_objx/lv_led.c", "function": "uint8_t lv_led_get_bright(const lv_obj_t * led)\n{\n    LV_ASSERT_OBJ(led, LV_OBJX_NAME);\n\n    lv_led_ext_t * ext = lv_obj_get_ext_attr(led);\n    return ext->bright;\n}", "summary": "Get the brightness of a LEd object"}
{"file_path": "/home/Downloads/project/platform/qpc/3rd_party/uCOS-II/Ports/ARM-Cortex-M4/Generic/ARM/os_cpu_c.c", "function": "void  OSTaskSwHook (void)\n{\n\n#if (OS_CPU_ARM_FP_EN > 0u)\n    if ((OSTCBCur->OSTCBOpt & OS_TASK_OPT_SAVE_FP) != (INT16U)0) {\n        OS_CPU_FP_Reg_Push(OSTCBCur->OSTCBStkPtr);\n    }\n\n    if ((OSTCBHighRdy->OSTCBOpt & OS_TASK_OPT_SAVE_FP) != (INT16U)0) {\n        OS_CPU_FP_Reg_Pop(OSTCBHighRdy->OSTCBStkPtr);\n    }\n#endif\n\n#if OS_APP_HOOKS_EN > 0u\n    App_TaskSwHook();\n#endif\n}", "summary": "This function is called when a task switch is performed"}
{"file_path": "/home/Downloads/project/c-project/curl/src/tool_paramhlp.c", "function": "int check_protocol(const char *str)\n{\n  const char * const *pp;\n  const curl_version_info_data *curlinfo = curl_version_info(CURLVERSION_NOW);\n  if(!str)\n    return PARAM_REQUIRES_PARAMETER;\n  for(pp = curlinfo->protocols; *pp; pp++) {\n    if(curl_strequal(*pp, str))\n      return PARAM_OK;\n  }\n  return PARAM_LIBCURL_UNSUPPORTED_PROTOCOL;\n}", "summary": "Check if the given string is a protocol supported by libcurl"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Cedar/Account.c", "function": "void *NewUserCertAuthData(X *x)\n{\n\tAUTHUSERCERT *a;\n\n\ta = ZeroMalloc(sizeof(AUTHUSERCERT));\n\ta->UserX = CloneX(x);\n\n\treturn a;\n}", "summary": "Create an authentication data for user certification"}
{"file_path": "/home/Downloads/project/homebrew/vifm/src/flist_pos.c", "function": "get_last_ext(const char name[])\n{\n\tconst char *const ext = strrchr(name, '.');\n\treturn (ext == NULL) ? (name + strlen(name)) : (ext + 1);\n}", "summary": "Finds pointer to the beginning of the last extension of the file name"}
{"file_path": "/home/Downloads/project/c-project/obs-studio/libobs/audio-monitoring/pulse/pulseaudio-wrapper.c", "function": "static void pulseaudio_context_state_changed(pa_context *c, void *userdata)\n{\n\tUNUSED_PARAMETER(userdata);\n\tUNUSED_PARAMETER(c);\n\n\tpulseaudio_signal(0);\n}", "summary": "context status change callback"}
{"file_path": "/home/Downloads/project/homebrew/mtr/test/packet_listen.c", "function": "int get_packet_pattern(\n    unsigned char *packet,\n    int packet_size)\n{\n    int fill_value;\n    int i;\n\n    if (packet_size <= 0) {\n        return -1;\n    }\n\n    fill_value = packet[0];\n    for (i = 1; i < packet_size; i++) {\n        if (packet[i] != fill_value) {\n            return -1;\n        }\n    }\n\n    return fill_value;\n}", "summary": "Check that all the bytes in the body of the packet have the same value"}
{"file_path": "/home/Downloads/project/c-project/postgres/src/backend/commands/foreigncmds.c", "function": "RemoveForeignDataWrapperById(Oid fdwId)\n{\n\tHeapTuple\ttp;\n\tRelation\trel;\n\n\trel = table_open(ForeignDataWrapperRelationId, RowExclusiveLock);\n\n\ttp = SearchSysCache1(FOREIGNDATAWRAPPEROID, ObjectIdGetDatum(fdwId));\n\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for foreign-data wrapper %u\", fdwId);\n\n\tCatalogTupleDelete(rel, &tp->t_self);\n\n\tReleaseSysCache(tp);\n\n\ttable_close(rel, RowExclusiveLock);\n}", "summary": "Drop foreign data wrapper by OID"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/media/pci/ivtv/ivtvfb.c", "function": "static void ivtvfb_restore(struct ivtv *itv)\n{\n\tstruct osd_info *oi = itv->osd_info;\n\tint i;\n\n\tivtvfb_set_var(itv, &oi->fbvar_cur);\n\tivtvfb_blank(oi->blank_cur, &oi->ivtvfb_info);\n\tfor (i = 0; i < 256; i++) {\n\t\twrite_reg(i, 0x02a30);\n\t\twrite_reg(oi->palette_cur[i], 0x02a34);\n\t}\n\twrite_reg(oi->pan_cur, 0x02a0c);\n}", "summary": "Restore hardware after firmware restart"}
{"file_path": "/home/Downloads/project/c-project/postgres/src/backend/utils/cache/lsyscache.c", "function": "get_op_opfamily_sortfamily(Oid opno, Oid opfamily)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(AMOP_ORDER),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopsortfamily;\n\tReleaseSysCache(tp);\n\treturn result;\n}", "summary": "If the operator is an ordering operator within the specified opfamily return its amopsortfamily OID else return InvalidOid"}
{"file_path": "/home/Downloads/project/homebrew/sqlcipher/ext/fts3/fts3_snippet.c", "function": "static int fts3ExprIterate2(\n  Fts3Expr *pExpr,                /* Expression to iterate phrases of */\n  int *piPhrase,                  /* Pointer to phrase counter */\n  int (*x)(Fts3Expr*,int,void*),  /* Callback function to invoke for phrases */\n  void *pCtx                      /* Second argument to pass to callback */\n){\n  int rc;                         /* Return code */\n  int eType = pExpr->eType;     /* Type of expression node pExpr */\n\n  if( eType!=FTSQUERY_PHRASE ){\n    assert( pExpr->pLeft && pExpr->pRight );\n    rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx);\n    if( rc==SQLITE_OK && eType!=FTSQUERY_NOT ){\n      rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx);\n    }\n  }else{\n    rc = x(pExpr, *piPhrase, pCtx);\n    (*piPhrase)++;\n  }\n  return rc;\n}", "summary": "Helper function for fts3ExprIterate see below"}
{"file_path": "/home/Downloads/project/c-project/HarmonyOS/Huawei_LiteOS/targets/NXP_LPC51U68/Driver/LPC51U68/system_LPC51U68.c", "function": "static uint32_t findPllPostDiv(uint32_t ctrlReg, uint32_t pDecReg)\n{\n    uint32_t postDiv = 1;\n\n    /* Direct input is not used? */\n    if ((ctrlReg & SYSCON_SYSPLLCTRL_DIRECTO_MASK) == 0)\n    {\n        /* Decode PDEC value to get (P) post divider */\n        postDiv = 2 * pllDecodeP(pDecReg & 0x7F);\n        if (postDiv == 0)\n        {\n            postDiv = 2;\n        }\n    }\n    /* Adjusted by 1, directo is used to bypass */\n    return postDiv;\n}", "summary": "Get postdivider P from PLL PDEC setting"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/misc/vmw_vmci/vmci_event.c", "function": "static void event_deliver(struct vmci_event_msg *event_msg)\n{\n\tstruct vmci_subscription *cur;\n\tstruct list_head *subscriber_list;\n\n\trcu_read_lock();\n\tsubscriber_list = &subscriber_array[event_msg->event_data.event];\n\tlist_for_each_entry_rcu(cur, subscriber_list, node) {\n\t\tcur->callback(cur->id, &event_msg->event_data,\n\t\t\t      cur->callback_data);\n\t}\n\trcu_read_unlock();\n}", "summary": "Actually delivers the events to the subscribers"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/usb/dwc2/core.c", "function": "bool dwc2_hw_is_host(struct dwc2_hsotg *hsotg)\n{\n\tunsigned int op_mode = dwc2_op_mode(hsotg);\n\n\treturn (op_mode == GHWCFG2_OP_MODE_SRP_CAPABLE_HOST) ||\n\t\t(op_mode == GHWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST);\n}", "summary": "Returns true if the controller is host only"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/tty/synclink_gt.c", "function": "static int synclink_gt_proc_show(struct seq_file *m, void *v)\n{\n\tstruct slgt_info *info;\n\n\tseq_puts(m, \"synclink_gt driver\\n\");\n\n\tinfo = slgt_device_list;\n\twhile( info ) {\n\t\tline_info(m, info);\n\t\tinfo = info->next_device;\n\t}\n\treturn 0;\n}", "summary": "Called to print information about devices"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/char/xilinx_hwicap/fifo_icap.c", "function": "static inline void fifo_icap_start_config(struct hwicap_drvdata *drvdata)\n{\n\tout_be32(drvdata->base_address + XHI_CR_OFFSET, XHI_CR_WRITE_MASK);\n\tdev_dbg(drvdata->dev, \"configuration started\\n\");\n}", "summary": "Initiate a configuration write to the device"}
{"file_path": "/home/Downloads/project/c-project/darwin-xnu/osfmk/vm/vm_user.c", "function": "mach_make_memory_entry_64(\n\tvm_map_t\t\ttarget_map,\n\tmemory_object_size_t\t*size,\n\tmemory_object_offset_t offset,\n\tvm_prot_t\t\tpermission,\n\tipc_port_t\t\t*object_handle,\n\tipc_port_t\t\tparent_handle)\n{\n\tif ((permission & MAP_MEM_FLAGS_MASK) & ~MAP_MEM_FLAGS_USER) {\n\t\t/*\n\t\t * Unknown flag: reject for forward compatibility.\n\t\t */\n\t\treturn KERN_INVALID_VALUE;\n\t}\n\n\treturn mach_make_memory_entry_internal(target_map,\n\t\t\t\t\t       size,\n\t\t\t\t\t       offset,\n\t\t\t\t\t       permission,\n\t\t\t\t\t       object_handle,\n\t\t\t\t\t       parent_handle);\n}", "summary": "Think of it as a two stage vm_remap operation"}
{"file_path": "/home/Downloads/project/c-project/linux/fs/exec.c", "function": "void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}", "summary": "These functions flushes out all traces of the currently running executable so that a new one can be started"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/rapidio/devices/tsi721_dma.c", "function": "static irqreturn_t tsi721_bdma_msix(int irq, void *ptr)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = ptr;\n\n\tif (bdma_chan->active)\n\t\ttasklet_hi_schedule(&bdma_chan->tasklet);\n\treturn IRQ_HANDLED;\n}", "summary": "tsi721_omsg_msix MSI X interrupt handler for BDMA channels"}
{"file_path": "/home/Downloads/project/homebrew/rsyslog/contrib/imdocker/imdocker.c", "function": "dockerContLogReqsAdd(docker_cont_log_instances_t *pThis,\n\t\tdocker_cont_logs_inst_t *pContLogsReqInst)\n{\n\tDEFiRet;\n\tif (!pContLogsReqInst) {\n\t\treturn RS_RET_ERR;\n\t}\n\n\tuchar *keyName = (uchar*)strdup((char*)pContLogsReqInst->id);\n\n\tif (keyName) {\n\t\tdocker_cont_logs_inst_t *pFind;\n\t\tif (RS_RET_NOT_FOUND == dockerContLogReqsGet(pThis, &pFind, (void*)keyName)) {\n\t\t\tif (!hashtable_insert(pThis->ht_container_log_insts, keyName, pContLogsReqInst)) {\n\t\t\t\tABORT_FINALIZE(RS_RET_ERR);\n\t\t\t}\n\t\t\tkeyName = NULL;\n\t\t}\n\t}\nfinalize_it:\n\tfree(keyName);\n\tRETiRet;\n}", "summary": "NOTE not thread safe"}
{"file_path": "/home/Downloads/project/c-project/linux/security/integrity/ima/ima_template_lib.c", "function": "int ima_eventsig_init(struct ima_event_data *event_data,\n\t\t      struct ima_field_data *field_data)\n{\n\tstruct evm_ima_xattr_data *xattr_value = event_data->xattr_value;\n\n\tif ((!xattr_value) || (xattr_value->type != EVM_IMA_XATTR_DIGSIG))\n\t\treturn 0;\n\n\treturn ima_write_template_field_data(xattr_value, event_data->xattr_len,\n\t\t\t\t\t     DATA_FMT_HEX, field_data);\n}", "summary": "include the file signature as part of the template data"}
{"file_path": "/home/Downloads/project/homebrew/yubikey-personalization/tests/test_args_to_config.c", "function": "static int _parse_args_rc(int argc, char *argv[])\n{\n\tYKP_CONFIG *cfg = ykp_alloc();\n\tYK_STATUS *st = _test_init_st(2, 2, 0);\n\tint rc = 0;\n\n\trc = _test_config(cfg, st, argc, argv);\n\n\tykp_free_config(cfg);\n\tfree(st);\n\n\treturn rc;\n}", "summary": "Utility function to parse arguments and just return the result code"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/intel/ice/ice_txrx_lib.c", "function": "ice_process_skb_fields(struct ice_ring *rx_ring,\n\t\t       union ice_32b_rx_flex_desc *rx_desc,\n\t\t       struct sk_buff *skb, u8 ptype)\n{\n\tice_rx_hash(rx_ring, rx_desc, skb, ptype);\n\n\t/* modifies the skb - consumes the enet header */\n\tskb->protocol = eth_type_trans(skb, rx_ring->netdev);\n\n\tice_rx_csum(rx_ring, skb, rx_desc, ptype);\n}", "summary": "Populate skb header fields from Rx descriptor"}
{"file_path": "/home/Downloads/project/c-project/darwin-xnu/bsd/net/if_loop.c", "function": "lo_input(struct ifnet *ifp, protocol_family_t protocol_family, struct mbuf *m)\n{\n#pragma unused(ifp, protocol_family)\n\n\tif ((ifp->if_xflags & IFXF_TIMESTAMP_ENABLED) != 0) {\n\t\terrno_t error;\n\t\tstruct timespec now;\n\t\tu_int64_t ts;\n\n\t\tnanouptime(&now);\n\t\tnet_timernsec(&now, &ts);\n\n\t\terror = mbuf_set_timestamp(m, ts, TRUE);\n\t\tif (error != 0)\n\t\t\tprintf(\"%s: mbuf_set_timestamp() failed %d\\n\",\n\t\t\t\t__func__, error);\n\t}\n\n\tif (proto_input(protocol_family, m) != 0)\n\t\tm_freem(m);\n\treturn (0);\n}", "summary": "This should work for all attached protocols that use the ifq schednetisr input mechanism"}
{"file_path": "/home/Downloads/project/c-project/linux/net/rxrpc/key.c", "function": "static int rxrpc_vet_description_s(const char *desc)\n{\n\tunsigned long num;\n\tchar *p;\n\n\tnum = simple_strtoul(desc, &p, 10);\n\tif (*p != ':' || num > 65535)\n\t\treturn -EINVAL;\n\tnum = simple_strtoul(p + 1, &p, 10);\n\tif (*p || num < 1 || num > 255)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "summary": "Vet the description for an RxRPC server key"}
{"file_path": "/home/Downloads/project/c-project/linux/sound/pci/trident/trident_main.c", "function": "static void snd_trident_free_pcm_channel(struct snd_trident *trident, int channel)\n{\n\tif (channel < 32 || channel > 63)\n\t\treturn;\n\tchannel &= 0x1f;\n\tif (trident->ChanMap[T4D_BANK_B] & (1 << channel)) {\n\t\ttrident->ChanMap[T4D_BANK_B] &= ~(1 << channel);\n\t\ttrident->ChanPCMcnt--;\n\t}\n}", "summary": "Free hardware channel in Bank B 32 63 Parameters trident pointer to target device class for 4DWave"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/scsi/fcoe/fcoe_ctlr.c", "function": "int fcoe_libfc_config(struct fc_lport *lport, struct fcoe_ctlr *fip,\n\t\t      const struct libfc_function_template *tt, int init_fcp)\n{\n\t/* Set the function pointers set by the LLDD */\n\tmemcpy(&lport->tt, tt, sizeof(*tt));\n\tif (init_fcp && fc_fcp_init(lport))\n\t\treturn -ENOMEM;\n\tfc_exch_init(lport);\n\tfc_elsct_init(lport);\n\tfc_lport_init(lport);\n\tfc_disc_init(lport);\n\tfcoe_ctlr_mode_set(lport, fip, fip->mode);\n\treturn 0;\n}", "summary": "Sets up libfc related properties for local port"}
{"file_path": "/home/Downloads/project/c-project/anypixel/firmware/display/ThirdParty/SPL/src/stm32f0xx_crc.c", "function": "uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)\n{\n  uint32_t index = 0;\n  \n  for(index = 0; index < BufferLength; index++)\n  {\n    CRC->DR = pBuffer[index];\n  }\n  return (CRC->DR);\n}", "summary": "Computes the 32 bit CRC of a given buffer of data word 32 bit"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/wireless/ath/ath6kl/usb.c", "function": "static void hif_start(struct ath6kl *ar)\n{\n\tstruct ath6kl_usb *device = ath6kl_usb_priv(ar);\n\tint i;\n\n\tath6kl_usb_start_recv_pipes(device);\n\n\t/* set the TX resource avail threshold for each TX pipe */\n\tfor (i = ATH6KL_USB_PIPE_TX_CTRL;\n\t     i <= ATH6KL_USB_PIPE_TX_DATA_HP; i++) {\n\t\tdevice->pipes[i].urb_cnt_thresh =\n\t\t    device->pipes[i].urb_alloc / 2;\n\t}\n}", "summary": "exported hif usb APIs for htc pipe"}
{"file_path": "/home/Downloads/project/c-project/darwin-xnu/osfmk/kern/locks.c", "function": "hw_lock_try_internal(hw_lock_t lock, thread_t thread)\n{\n\tint\t\tsuccess = 0;\n\n#if\t__SMP__\n#if\tLOCK_PRETEST\n\tif (ordered_load_hw(lock))\n\t\tgoto failed;\n#endif\t// LOCK_PRETEST\n\tsuccess = atomic_compare_exchange(&lock->lock_data, 0, LCK_MTX_THREAD_TO_STATE(thread) | PLATFORM_LCK_ILOCK,\n\t\t\t\t\tmemory_order_acquire_smp, FALSE);\n#else\n\tif (lock->lock_data == 0) {\n\t\tlock->lock_data = LCK_MTX_THREAD_TO_STATE(thread) | PLATFORM_LCK_ILOCK;\n\t\tsuccess = 1;\n\t}\n#endif\t// __SMP__\n\n#if\tLOCK_PRETEST\nfailed:\n#endif\t// LOCK_PRETEST\n#if CONFIG_DTRACE\n\tif (success)\n\t\tLOCKSTAT_RECORD(LS_LCK_SPIN_LOCK_ACQUIRE, lock, 0);\n#endif\n\treturn success;\n}", "summary": "Routine hw_lock_try returns with preemption disabled on success"}
{"file_path": "/home/Downloads/project/c-project/linux/kernel/time/posix-timers.c", "function": "static __init int init_posix_timers(void)\n{\n\tposix_timers_cache = kmem_cache_create(\"posix_timers_cache\",\n\t\t\t\t\tsizeof (struct k_itimer), 0, SLAB_PANIC,\n\t\t\t\t\tNULL);\n\treturn 0;\n}", "summary": "Initialize everything well just everything in Posix clocks timers"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/hwmon/hwmon.c", "function": "struct device *hwmon_device_register(struct device *dev)\n{\n\tdev_warn(dev,\n\t\t \"hwmon_device_register() is deprecated. Please convert the driver to use hwmon_device_register_with_info().\\n\");\n\n\treturn __hwmon_device_register(dev, NULL, NULL, NULL, NULL);\n}", "summary": "register w hwmon"}
{"file_path": "/home/Downloads/project/homebrew/strongswan/src/libcharon/plugins/kernel_wfp/kernel_wfp_ipsec.c", "function": "static void free_condition(FWP_DATA_TYPE type, void *value)\n{\n\tFWP_RANGE0 *range;\n\n\tswitch (type)\n\t{\n\t\tcase FWP_BYTE_ARRAY16_TYPE:\n\t\tcase FWP_V4_ADDR_MASK:\n\t\tcase FWP_V6_ADDR_MASK:\n\t\t\tfree(value);\n\t\t\tbreak;\n\t\tcase FWP_RANGE_TYPE:\n\t\t\trange = value;\n\t\t\tfree_condition(range->valueLow.type, range->valueLow.sd);\n\t\t\tfree_condition(range->valueHigh.type, range->valueHigh.sd);\n\t\t\tfree(range);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}", "summary": "Free memory associated to a single condition"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/video/fbdev/cyber2000fb.c", "function": "static void cyberpro_init_hw(struct cfb_info *cfb)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(igs_regs); i += 2)\n\t\tcyber2000_grphw(igs_regs[i], igs_regs[i + 1], cfb);\n\n\tif (cfb->id == ID_CYBERPRO_5000) {\n\t\tunsigned char val;\n\t\tcyber2000fb_writeb(0xba, 0x3ce, cfb);\n\t\tval = cyber2000fb_readb(0x3cf, cfb) & 0x80;\n\t\tcyber2000fb_writeb(val, 0x3cf, cfb);\n\t}\n}", "summary": "Initialise the CyberPro hardware"}
{"file_path": "/home/Downloads/project/c-project/numpy/numpy/core/src/multiarray/alloc.c", "function": "PyDataMem_SetEventHook(PyDataMem_EventHookFunc *newhook,\n                       void *user_data, void **old_data)\n{\n    PyDataMem_EventHookFunc *temp;\n    NPY_ALLOW_C_API_DEF\n    NPY_ALLOW_C_API\n    temp = _PyDataMem_eventhook;\n    _PyDataMem_eventhook = newhook;\n    if (old_data != NULL) {\n        *old_data = _PyDataMem_eventhook_user_data;\n    }\n    _PyDataMem_eventhook_user_data = user_data;\n    NPY_DISABLE_C_API\n    return temp;\n}", "summary": "NUMPY_API Sets the allocation event hook for numpy array data"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/video/console/newport_con.c", "function": "static const char *newport_startup(void)\n{\n\tint i;\n\n\tnpregs->cset.config = NPORT_CFG_GD0;\n\n\tif (newport_wait(npregs))\n\t\tgoto out_unmap;\n\n\tnpregs->set.xstarti = TESTVAL;\n\tif (npregs->set._xstart.word != XSTI_TO_FXSTART(TESTVAL))\n\t\tgoto out_unmap;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tfont_data[i] = FONT_DATA;\n\n\tnewport_reset();\n\tnewport_get_revisions();\n\tnewport_get_screensize();\n\tnewport_has_init = 1;\n\n\treturn \"SGI Newport\";\n\nout_unmap:\n\treturn NULL;\n}", "summary": "Ca n t be __init do_take_over_console may call it later"}
{"file_path": "/home/Downloads/project/c-project/linux/tools/perf/bench/numa.c", "function": "static void print_res(const char *name, double val,\n\t\t      const char *txt_unit, const char *txt_short, const char *txt_long)\n{\n\tif (!name)\n\t\tname = \"main,\";\n\n\tif (!g->p.show_quiet)\n\t\tprintf(\" %-30s %15.3f, %-15s %s\\n\", name, val, txt_unit, txt_short);\n\telse\n\t\tprintf(\" %14.3f %s\\n\", val, txt_long);\n}", "summary": "Print a short or long result depending on the verbosity setting"}
{"file_path": "/home/Downloads/project/homebrew/mlt/src/modules/plus/consumer_blipflash.c", "function": "static void consumer_close( mlt_consumer consumer )\n{\n\tmlt_properties consumer_properties = MLT_CONSUMER_PROPERTIES( consumer );\n\tavsync_stats* stats = mlt_properties_get_data( consumer_properties, \"_stats\", NULL );\n\n\t// Stop the consumer\n\tmlt_consumer_stop( consumer );\n\n\t// Close the file\n\tif( stats->out_file != stdout )\n\t{\n\t\tfclose( stats->out_file );\n\t}\n\n\t// Clean up memory\n\tmlt_pool_release( stats );\n\n\t// Close the parent\n\tmlt_consumer_close( consumer );\n\n\t// Free the memory\n\tfree( consumer );\n}", "summary": "Close the consumer"}
{"file_path": "/home/Downloads/project/c-project/redis/src/intset.c", "function": "static uint8_t _intsetValueEncoding(int64_t v) {\n    if (v < INT32_MIN || v > INT32_MAX)\n        return INTSET_ENC_INT64;\n    else if (v < INT16_MIN || v > INT16_MAX)\n        return INTSET_ENC_INT32;\n    else\n        return INTSET_ENC_INT16;\n}", "summary": "Return the required encoding for the provided value"}
{"file_path": "/home/Downloads/project/c-project/linux/sound/usb/line6/driver.c", "function": "int line6_resume(struct usb_interface *interface)\n{\n\tstruct usb_line6 *line6 = usb_get_intfdata(interface);\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL)\n\t\tline6_start_listen(line6);\n\n\tsnd_power_change_state(line6->card, SNDRV_CTL_POWER_D0);\n\treturn 0;\n}", "summary": "Resume Line 6 device"}
{"file_path": "/home/Downloads/project/c-project/linux/kernel/kprobes.c", "function": "static int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}", "summary": "Add the new probe to ap list"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/media/platform/s5p-mfc/s5p_mfc_opr_v6.c", "function": "static int s5p_mfc_alloc_dec_temp_buffers_v6(struct s5p_mfc_ctx *ctx)\n{\n\t/* NOP */\n\n\treturn 0;\n}", "summary": "Allocate temporary buffers for decoding"}
{"file_path": "/home/Downloads/project/c-project/postgres/src/backend/catalog/heap.c", "function": "SystemAttributeByName(const char *attname)\n{\n\tint\t\t\tj;\n\n\tfor (j = 0; j < (int) lengthof(SysAtt); j++)\n\t{\n\t\tconst FormData_pg_attribute *att = SysAtt[j];\n\n\t\tif (strcmp(NameStr(att->attname), attname) == 0)\n\t\t\treturn att;\n\t}\n\n\treturn NULL;\n}", "summary": "If the given name is a system attribute name return a Form_pg_attribute pointer for a prototype definition"}
{"file_path": "/home/Downloads/project/homebrew/konoha3/src/package-devel/Lib.Libvirt/libvirt_glue.c", "function": "static KMETHOD KvirDomainSnapshotRef(KonohaContext *kctx,  KonohaStack *sfp)\n{\n\tvirDomainSnapshotPtr arg0 = To_virDomainSnapshotPtr(sfp[0]);\n\tint ret = virDomainSnapshotRef (arg0);\n\tRETURNint(ret);\n}", "summary": "virDomainSnapshotRef int virDomainSnapshotPtr"}
{"file_path": "/home/Downloads/project/homebrew/suricata/src/app-layer-parser.c", "function": "void AppLayerParserStateSetFlag(AppLayerParserState *pstate, uint8_t flag)\n{\n    SCEnter();\n    pstate->flags |= flag;\n    SCReturn;\n}", "summary": "coccinelle AppLayerParserStateSetFlag 2 2 APP_LAYER_PARSER_"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/wireless/st/cw1200/cw1200_spi.c", "function": "static int cw1200_spi_disconnect(struct spi_device *func)\n{\n\tstruct hwbus_priv *self = spi_get_drvdata(func);\n\n\tif (self) {\n\t\tcw1200_spi_irq_unsubscribe(self);\n\t\tif (self->core) {\n\t\t\tcw1200_core_release(self->core);\n\t\t\tself->core = NULL;\n\t\t}\n\t}\n\tcw1200_spi_off(dev_get_platdata(&func->dev));\n\n\treturn 0;\n}", "summary": "to be called by SPI stack when device is disconnected"}
{"file_path": "/home/Downloads/project/c-project/radare2/libr/util/regex/regcomp.c", "function": "static void freeset(struct parse *p, cset *cs) {\n\tint i;\n\tcset *top = &p->g->sets[p->g->ncsets];\n\tsize_t css = (size_t)p->g->csetsize;\n\n\tfor (i = 0; i < css; i++) {\n\t\tCHsub (cs, i);\n\t}\n\tif (cs == top - 1) { /* recover only the easy case */\n\t\tp->g->ncsets--;\n\t}\n}", "summary": "free a now unused set"}
{"file_path": "/home/Downloads/project/c-project/vlc/modules/audio_output/oss.c", "function": "static void Pause (audio_output_t *aout, bool pause, vlc_tick_t date)\n{\n    aout_sys_t *sys = aout->sys;\n    int fd = sys->fd;\n\n    (void) date;\n    ioctl (fd, pause ? SNDCTL_DSP_SILENCE : SNDCTL_DSP_SKIP, NULL);\n}", "summary": "s resumes the audio playback"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/usb/core/sysfs.c", "function": "static ssize_t interface_authorized_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\n\treturn sprintf(buf, \"%u\\n\", intf->authorized);\n}", "summary": "show authorization status of an USB interface 1 is authorized 0 is deauthorized"}
{"file_path": "/home/Downloads/project/homebrew/tcpreplay/src/tcpprep_api.c", "function": "tcpprep_set_output_file(tcpprep_t *ctx, char *value)\n{\n    assert(ctx);\n    assert(value);\n    ctx->outfile = safe_strdup(value);\n    return 0;\n}", "summary": "Specify the tcpprep cache file to generate"}
{"file_path": "/home/Downloads/project/platform/qpc/3rd_party/lwip/src/netif/ppp/lcp.c", "function": "lcp_input(int unit, u_char *p, int len)\n{\n  fsm *f = &lcp_fsm[unit];\n\n  fsm_input(f, p, len);\n}", "summary": "Input LCP packet"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/ps3/ps3-vuart.c", "function": "int ps3_vuart_port_driver_register(struct ps3_vuart_port_driver *drv)\n{\n\tint result;\n\n\tpr_debug(\"%s:%d: (%s)\\n\", __func__, __LINE__, drv->core.core.name);\n\n\tBUG_ON(!drv->core.match_id);\n\tBUG_ON(!drv->core.core.name);\n\n\tdrv->core.probe = ps3_vuart_probe;\n\tdrv->core.remove = ps3_vuart_remove;\n\tdrv->core.shutdown = ps3_vuart_shutdown;\n\n\tresult = ps3_system_bus_driver_register(&drv->core);\n\treturn result;\n}", "summary": "Add a vuart port device driver"}
{"file_path": "/home/Downloads/project/c-project/zstd/lib/compress/zstd_ldm.c", "function": "static rawSeq maybeSplitSequence(rawSeqStore_t* rawSeqStore,\n                                 U32 const remaining, U32 const minMatch)\n{\n    rawSeq sequence = rawSeqStore->seq[rawSeqStore->pos];\n    assert(sequence.offset > 0);\n    /* Likely: No partial sequence */\n    if (remaining >= sequence.litLength + sequence.matchLength) {\n        rawSeqStore->pos++;\n        return sequence;\n    }\n    /* Cut the sequence short (offset == 0 ==> rest is literals). */\n    if (remaining <= sequence.litLength) {\n        sequence.offset = 0;\n    } else if (remaining < sequence.litLength + sequence.matchLength) {\n        sequence.matchLength = remaining - sequence.litLength;\n        if (sequence.matchLength < minMatch) {\n            sequence.offset = 0;\n        }\n    }\n    /* Skip past `remaining` bytes for the future sequences. */\n    ZSTD_ldm_skipSequences(rawSeqStore, remaining, minMatch);\n    return sequence;\n}", "summary": "If the sequence length is longer than remaining then the sequence is split between this block and the next"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/h8300/kernel/process.c", "function": "asmlinkage int sys_clone(unsigned long __user *args)\n{\n\tunsigned long clone_flags;\n\tunsigned long  newsp;\n\tuintptr_t parent_tidptr;\n\tuintptr_t child_tidptr;\n\n\tget_user(clone_flags, &args[0]);\n\tget_user(newsp, &args[1]);\n\tget_user(parent_tidptr, &args[2]);\n\tget_user(child_tidptr, &args[3]);\n\treturn do_fork(clone_flags, newsp, 0,\n\t\t       (int __user *)parent_tidptr, (int __user *)child_tidptr);\n}", "summary": "generic sys_clone is not enough registers"}
{"file_path": "/home/Downloads/project/c-project/robotjs/src/mouse.c", "function": "void doubleClick(MMMouseButton button)\n{\n\n#if defined(IS_MACOSX)\n\n\t/* Double click for Mac. */\n\tconst CGPoint currentPos = CGPointFromMMPoint(getMousePos());\n\tconst CGEventType mouseTypeDown = MMMouseToCGEventType(true, button);\n\tconst CGEventType mouseTypeUP = MMMouseToCGEventType(false, button);\n\n\tCGEventRef event = CGEventCreateMouseEvent(NULL, mouseTypeDown, currentPos, kCGMouseButtonLeft);\n\n\t/* Set event to double click. */\n\tCGEventSetIntegerValueField(event, kCGMouseEventClickState, 2);\n\n\tCGEventPost(kCGHIDEventTap, event);\n\n\tCGEventSetType(event, mouseTypeUP);\n\tCGEventPost(kCGHIDEventTap, event);\n\n\tCFRelease(event);\n\n#else\n\n\t/* Double click for everything else. */\n\tclickMouse(button);\n\tmicrosleep(200);\n\tclickMouse(button);\n\n#endif\n}", "summary": "Special function for sending double clicks needed for Mac OS X"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/wireless/intel/ipw2x00/ipw2200.c", "function": "static inline void ipw_write_reg32(struct ipw_priv *a, u32 b, u32 c)\n{\n\tIPW_DEBUG_IO(\"%s %d: write_indirect32(0x%08X, 0x%08X)\\n\", __FILE__,\n\t\t     __LINE__, (u32) (b), (u32) (c));\n\t_ipw_write_reg32(a, b, c);\n}", "summary": "32 bit indirect write for SRAM reg above 4K with debug wrapper"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/atheros/atl1c/atl1c_main.c", "function": "static int atl1c_close(struct net_device *netdev)\n{\n\tstruct atl1c_adapter *adapter = netdev_priv(netdev);\n\n\tWARN_ON(test_bit(__AT_RESETTING, &adapter->flags));\n\tset_bit(__AT_DOWN, &adapter->flags);\n\tcancel_work_sync(&adapter->common_task);\n\tatl1c_down(adapter);\n\tatl1c_free_ring_resources(adapter);\n\treturn 0;\n}", "summary": "Disables a network interface"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/watchdog/booke_wdt.c", "function": "static unsigned int sec_to_period(unsigned int secs)\n{\n\tunsigned int period;\n\tfor (period = 63; period > 0; period--) {\n\t\tif (period_to_sec(period) >= secs)\n\t\t\treturn period;\n\t}\n\treturn 0;\n}", "summary": "This procedure will find the highest period which will give a timeout greater than the one required"}
{"file_path": "/home/Downloads/project/c-project/SoftEtherVPN/src/Mayaqua/Network.c", "function": "void FreeRouteTable(ROUTE_TABLE *t)\n{\n\tUINT i;\n\t// Validate arguments\n\tif (t == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0;i < t->NumEntry;i++)\n\t{\n\t\tFree(t->Entry[i]);\n\t}\n\tFree(t->Entry);\n\tFree(t);\n}", "summary": "Release of the routing table"}
{"file_path": "/home/Downloads/project/c-project/nodemcu-firmware/app/modules/i2c.c", "function": "static int i2c_read( lua_State *L )\n{\n  unsigned id = luaL_checkinteger( L, 1 );\n  u32 size = ( u32 )luaL_checkinteger( L, 2 ), i;\n  luaL_Buffer b;\n  int data;\n\n  MOD_CHECK_ID( i2c, id );\n  if( size == 0 )\n    return 0;\n  luaL_buffinit( L, &b );\n  for( i = 0; i < size; i ++ )\n    if( ( data = platform_i2c_recv_byte( id, i < size - 1 ) ) == -1 )\n      break;\n    else\n      luaL_addchar( &b, ( char )data );\n  luaL_pushresult( &b );\n  return 1;\n}", "summary": "Lua read i2c read id size"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/net/ethernet/amd/au1000_eth.c", "function": "static void au1000_tx_timeout(struct net_device *dev)\n{\n\tnetdev_err(dev, \"au1000_tx_timeout: dev=%p\\n\", dev);\n\tau1000_reset_mac(dev);\n\tau1000_init(dev);\n\tnetif_trans_update(dev); /* prevent tx timeout */\n\tnetif_wake_queue(dev);\n}", "summary": "The Tx ring has been full longer than the watchdog timeout value"}
{"file_path": "/home/Downloads/project/homebrew/ettercap/src/ec_sniff.c", "function": "static void add_ip(void *digit, u_int n)\n{\n   struct digit *buf = digit;\n   \n   buf->n++;\n   buf->values[buf->n - 1] = (u_char) n;\n}", "summary": "fill the digit structure with data"}
{"file_path": "/home/Downloads/project/c-project/linux/kernel/locking/rtmutex.c", "function": "void rt_mutex_init_proxy_locked(struct rt_mutex *lock,\n\t\t\t\tstruct task_struct *proxy_owner)\n{\n\t__rt_mutex_init(lock, NULL, NULL);\n\tdebug_rt_mutex_proxy_lock(lock, proxy_owner);\n\trt_mutex_set_owner(lock, proxy_owner);\n}", "summary": "initialize and lock a rt_mutex on behalf of a proxy owner"}
{"file_path": "/home/Downloads/project/c-project/linux/net/ipv4/tcp_input.c", "function": "void tcp_synack_rtt_meas(struct sock *sk, struct request_sock *req)\n{\n\tstruct rate_sample rs;\n\tlong rtt_us = -1L;\n\n\tif (req && !req->num_retrans && tcp_rsk(req)->snt_synack)\n\t\trtt_us = tcp_stamp_us_delta(tcp_clock_us(), tcp_rsk(req)->snt_synack);\n\n\ttcp_ack_update_rtt(sk, FLAG_SYN_ACKED, rtt_us, -1L, rtt_us, &rs);\n}", "summary": "Compute time elapsed between last SYNACK and the ACK completing 3WHS"}
{"file_path": "/home/Downloads/project/homebrew/bladeRF/host/libraries/libbladeRF/src/bladerf.c", "function": "int bladerf_open(struct bladerf **dev, const char *dev_id)\n{\n    struct bladerf_devinfo devinfo;\n    int status;\n\n    *dev = NULL;\n\n    /* Populate dev-info from string */\n    status = str2devinfo(dev_id, &devinfo);\n    if (!status) {\n        status = bladerf_open_with_devinfo(dev, &devinfo);\n    }\n\n    return status;\n}", "summary": "dev path becomes device specifier string osmosdr like"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/hwmon/asb100.c", "function": "static u8 IN_TO_REG(unsigned val)\n{\n\tunsigned nval = clamp_val(val, ASB100_IN_MIN, ASB100_IN_MAX);\n\treturn (nval + 8) / 16;\n}", "summary": "IN 1 1000 V 0V to 4 08V REG 16mV bit"}
{"file_path": "/home/Downloads/project/c-project/libevent/buffer.c", "function": "evbuffer_chain_should_realign(struct evbuffer_chain *chain,\n    size_t datlen)\n{\n\treturn chain->buffer_len - chain->off >= datlen &&\n\t    (chain->off < chain->buffer_len / 2) &&\n\t    (chain->off <= MAX_TO_REALIGN_IN_EXPAND);\n}", "summary": "Helper return true iff we should realign chain to fit datalen bytes of data in it"}
{"file_path": "/home/Downloads/project/homebrew/pacparser/src/spidermonkey/js/src/jsxml.c", "function": "OrphanXMLChild(JSContext *cx, JSXML *xml, uint32 i)\n{\n    JSXMLNamespace *ns;\n\n    ns = XMLARRAY_MEMBER(&xml->xml_namespaces, 0, JSXMLNamespace);\n    xml = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);\n    if (!ns || !xml)\n        return xml;\n    if (xml->xml_class == JSXML_CLASS_ELEMENT) {\n        if (!XMLARRAY_APPEND(cx, &xml->xml_namespaces, ns))\n            return NULL;\n        ns->declared = JS_FALSE;\n    }\n    xml->parent = NULL;\n    return xml;\n}", "summary": "Errata in 10 3 1 10 4 1 and 13 4 4 24 at least"}
{"file_path": "/home/Downloads/project/c-project/linux/security/selinux/netport.c", "function": "static void sel_netport_insert(struct sel_netport *port)\n{\n\tunsigned int idx;\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds */\n\tidx = sel_netport_hashfn(port->psec.port);\n\tlist_add_rcu(&port->list, &sel_netport_hash[idx].list);\n\tif (sel_netport_hash[idx].size == SEL_NETPORT_HASH_BKT_LIMIT) {\n\t\tstruct sel_netport *tail;\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tsel_netport_hash[idx].list.prev,\n\t\t\t\tlockdep_is_held(&sel_netport_lock)),\n\t\t\tstruct sel_netport, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else\n\t\tsel_netport_hash[idx].size++;\n}", "summary": "Add a new port record to the network address hash table"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/memory/pl353-smc.c", "function": "void pl353_smc_clr_nand_int(void)\n{\n\twritel(PL353_SMC_CFG_CLR_INT_CLR_1,\n\t       pl353_smc_base + PL353_SMC_CFG_CLR_OFFS);\n}", "summary": "Clear NAND interrupt"}
{"file_path": "/home/Downloads/project/c-project/HarmonyOS/Huawei_LiteOS/components/net/lwip/lwip-2.0.3/src/core/tcp_in.c", "function": "tcp_input_delayed_close(struct tcp_pcb *pcb)\n{\n  if (recv_flags & TF_CLOSED) {\n    /* The connection has been closed and we will deallocate the\n        PCB. */\n    if (!(pcb->flags & TF_RXCLOSED)) {\n      /* Connection closed although the application has only shut down the\n          tx side: call the PCB's err callback and indicate the closure to\n          ensure the application doesn't continue using the PCB. */\n      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);\n    }\n    tcp_pcb_remove(&tcp_active_pcbs, pcb);\n    memp_free(MEMP_TCP_PCB, pcb);\n    return 1;\n  }\n  return 0;\n}", "summary": "Called from tcp_input to check for TF_CLOSED flag"}
{"file_path": "/home/Downloads/project/c-project/linux/arch/x86/kernel/kvm.c", "function": "static void kvm_setup_pv_ipi(void)\n{\n\tapic->send_IPI_mask = kvm_send_ipi_mask;\n\tapic->send_IPI_mask_allbutself = kvm_send_ipi_mask_allbutself;\n\tpr_info(\"KVM setup pv IPIs\\n\");\n}", "summary": "Set the IPI entry points"}
{"file_path": "/home/Downloads/project/c-project/qemu/target/i386/cpu.c", "function": "static int nodes_in_socket(int nr_cores)\n{\n    int nodes;\n\n    nodes = DIV_ROUND_UP(nr_cores, MAX_CORES_IN_NODE);\n\n   /* Hardware does not support config with 3 nodes, return 4 in that case */\n    return (nodes == 3) ? 4 : nodes;\n}", "summary": "Figure out the number of nodes required to build this config"}
{"file_path": "/home/Downloads/project/c-project/h2o/deps/picotls/deps/cifra/src/curve25519.donna.c", "function": "static void fscalar_product(limb *output, const limb *in, const limb scalar) {\n  unsigned i;\n  for (i = 0; i < 10; ++i) {\n    output[i] = in[i] * scalar;\n  }\n}", "summary": "Multiply a number by a scalar output in scalar"}
{"file_path": "/home/Downloads/project/c-project/linux/virt/kvm/arm/hyp/aarch32.c", "function": "void __hyp_text kvm_skip_instr32(struct kvm_vcpu *vcpu, bool is_wide_instr)\n{\n\tbool is_thumb;\n\n\tis_thumb = !!(*vcpu_cpsr(vcpu) & PSR_AA32_T_BIT);\n\tif (is_thumb && !is_wide_instr)\n\t\t*vcpu_pc(vcpu) += 2;\n\telse\n\t\t*vcpu_pc(vcpu) += 4;\n\tkvm_adjust_itstate(vcpu);\n}", "summary": "kvm_skip_instr skip a trapped instruction and proceed to the next"}
{"file_path": "/home/Downloads/project/homebrew/Tor/src/or/routerlist.c", "function": "router_dir_info_changed(void)\n{\n  need_to_update_have_min_dir_info = 1;\n  rend_hsdir_routers_changed();\n}", "summary": "Called when our internal view of the directory has changed"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/media/mc/mc-devnode.c", "function": "static int __init media_devnode_init(void)\n{\n\tint ret;\n\n\tpr_info(\"Linux media interface: v0.10\\n\");\n\tret = alloc_chrdev_region(&media_dev_t, 0, MEDIA_NUM_DEVICES,\n\t\t\t\t  MEDIA_NAME);\n\tif (ret < 0) {\n\t\tpr_warn(\"unable to allocate major\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bus_register(&media_bus_type);\n\tif (ret < 0) {\n\t\tunregister_chrdev_region(media_dev_t, MEDIA_NUM_DEVICES);\n\t\tpr_warn(\"bus_register failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "summary": "Initialise media for linux"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/of/fdt_address.c", "function": "static void __init fdt_bus_default_count_cells(const void *blob, int parentoffset,\n\t\t\t\t\t       int *addrc, int *sizec)\n{\n\tconst __be32 *prop;\n\n\tif (addrc) {\n\t\tprop = fdt_getprop(blob, parentoffset, \"#address-cells\", NULL);\n\t\tif (prop)\n\t\t\t*addrc = be32_to_cpup(prop);\n\t\telse\n\t\t\t*addrc = dt_root_addr_cells;\n\t}\n\n\tif (sizec) {\n\t\tprop = fdt_getprop(blob, parentoffset, \"#size-cells\", NULL);\n\t\tif (prop)\n\t\t\t*sizec = be32_to_cpup(prop);\n\t\telse\n\t\t\t*sizec = dt_root_size_cells;\n\t}\n}", "summary": "Default translator generic bus"}
{"file_path": "/home/Downloads/project/c-project/linux/block/bfq-iosched.c", "function": "static void bfq_bfqq_end_wr(struct bfq_queue *bfqq)\n{\n\tif (bfq_bfqq_busy(bfqq))\n\t\tbfqq->bfqd->wr_busy_queues--;\n\tbfqq->wr_coeff = 1;\n\tbfqq->wr_cur_max_time = 0;\n\tbfqq->last_wr_start_finish = jiffies;\n\t/*\n\t * Trigger a weight change on the next invocation of\n\t * __bfq_entity_update_weight_prio.\n\t */\n\tbfqq->entity.prio_changed = 1;\n}", "summary": "Must be called with bfqq NULL"}
{"file_path": "/home/Downloads/project/platform/SSLClient/src/bearssl/src/hash/sha2small.c", "function": "br_sha224_init(br_sha224_context *cc)\n{\n\tcc->vtable = &br_sha224_vtable;\n\tmemcpy(cc->val, br_sha224_IV, sizeof cc->val);\n\tcc->count = 0;\n}", "summary": "see bearssl h"}
{"file_path": "/home/Downloads/project/c-project/linux/drivers/usb/host/sl811-hcd.c", "function": "static void create_debug_file(struct sl811 *sl811)\n{\n\tsl811->debug_file = debugfs_create_file(\"sl811h\", S_IRUGO,\n\t\t\t\t\t\tusb_debug_root, sl811,\n\t\t\t\t\t\t&sl811h_debug_fops);\n}", "summary": "expect just one sl811 per system"}
